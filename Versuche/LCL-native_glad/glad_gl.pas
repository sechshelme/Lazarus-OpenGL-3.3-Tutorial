{

    OpenGL loader generated by glad 0.1.36 on Wed Apr  3 11:04:43 2024.

    Language/Generator: Pascal
    Specification: gl
    APIs: gl=4.6
    Profile: core
    Extensions:
        
    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --profile="core" --api="gl=4.6" --generator="pascal" --spec="gl" --extensions=""
    Online:
        https://glad.dav1d.de/#profile=core&language=pascal&specification=gl&loader=on&api=gl%3D4.6
}
unit glad_gl;

{$IF Defined(FPC)}{$MODE Delphi}{$ENDIF}{$H+}

interface

uses
  SysUtils, StrUtils;

procedure Load_GLADE;


var
  glVersionMajor, glVersionMinor: integer;

  (* Types *)
type
  GLVULKANPROCNV = pointer;
  GLbitfield = uint32;
  GLboolean = byte;
  GLbyte = int8;
  GLchar = char;
  GLcharARB = byte;
  GLclampd = double;
  GLclampf = single;
  GLclampx = int32;
  GLdouble = double;
  GLeglClientBufferEXT = pointer;
  GLeglImageOES = pointer;
  GLenum = uint32;
  GLfixed = int32;
  GLfloat = single;
  GLhalf = uint16;
  GLhalfARB = uint16;
  GLhalfNV = uint16;
  GLhandleARB = uint32;
  GLint = int32;
  GLint64 = int64;
  GLint64EXT = int64;
  GLintptr = int32;
  GLintptrARB = int32;
  GLshort = int16;
  GLsizei = int32;
  GLsizeiptr = int32;
  GLsizeiptrARB = int32;
  GLsync = pointer;
  GLubyte = uint8;
  GLuint = uint32;
  GLuint64 = uint64;
  GLuint64EXT = uint64;
  GLushort = uint16;
  GLvdpauSurfaceNV = int32;
  GLvoid = pointer;
  _cl_context = pointer;
  _cl_event = pointer;

  PGLVULKANPROCNV = ^pointer;
  PGLbitfield = ^uint32;
  PGLboolean = ^byte;
  PGLbyte = ^int8;
  PGLchar = ^char;
  PGLcharARB = ^byte;
  PGLclampd = ^double;
  PGLclampf = ^single;
  PGLclampx = ^int32;
  PGLdouble = ^double;
  PGLeglClientBufferEXT = ^pointer;
  PGLeglImageOES = ^pointer;
  PGLenum = ^uint32;
  PGLfixed = ^int32;
  PGLfloat = ^single;
  PGLhalf = ^uint16;
  PGLhalfARB = ^uint16;
  PGLhalfNV = ^uint16;
  PGLhandleARB = ^uint32;
  PGLint = ^int32;
  PGLint64 = ^int64;
  PGLint64EXT = ^int64;
  PGLintptr = ^int32;
  PGLintptrARB = ^int32;
  PGLshort = ^int16;
  PGLsizei = ^int32;
  PGLsizeiptr = ^int32;
  PGLsizeiptrARB = ^int32;
  PGLsync = ^pointer;
  PGLubyte = ^uint8;
  PGLuint = ^uint32;
  PGLuint64 = ^uint64;
  PGLuint64EXT = ^uint64;
  PGLushort = ^uint16;
  PGLvdpauSurfaceNV = ^int32;
  PGLvoid = ^pointer;
  P_cl_context = ^pointer;
  P_cl_event = ^pointer;
  PPGLchar = ^PGLchar;
  PPGLcharARB = ^PGLcharARB;
  PPGLboolean = ^PGLboolean;

  GLdebugProc = procedure(
    Source: GLenum;
    typ: GLenum;
    id: GLuint;
    severity: GLenum;
    length: GLsizei;
    message: PGLchar;
    userParam: pointer); stdcall;
  GLdebugProcArb = GLdebugProc;
  GLdebugProcKhr = GLdebugProc;

  GLdebugProcAmd = procedure(
    id: GLuint;
    category: GLenum;
    severity: GLenum;
    len: GLsizei;
    message: PGLchar;
    userParam: pointer); stdcall;


  (* Enums *)
const
  GL_FALSE = 0;
  GL_INVALID_INDEX = uint32($FFFFFFFF);
  GL_NONE = 0;
  GL_NONE_OES = 0;
  GL_NO_ERROR = 0;
  GL_ONE = 1;
  GL_TIMEOUT_IGNORED = uint64($FFFFFFFFFFFFFFFF);
  GL_TIMEOUT_IGNORED_APPLE = uint64($FFFFFFFFFFFFFFFF);
  GL_TRUE = 1;
  GL_VERSION_ES_CL_1_0 = 1;
  GL_VERSION_ES_CL_1_1 = 1;
  GL_VERSION_ES_CM_1_1 = 1;
  GL_ZERO = 0;

  GL_DEPTH_BUFFER_BIT = $00000100;
  GL_STENCIL_BUFFER_BIT = $00000400;
  GL_COLOR_BUFFER_BIT = $00004000;
  GL_POINTS = $0000;
  GL_LINES = $0001;
  GL_LINE_LOOP = $0002;
  GL_LINE_STRIP = $0003;
  GL_TRIANGLES = $0004;
  GL_TRIANGLE_STRIP = $0005;
  GL_TRIANGLE_FAN = $0006;
  GL_NEVER = $0200;
  GL_LESS = $0201;
  GL_EQUAL = $0202;
  GL_LEQUAL = $0203;
  GL_GREATER = $0204;
  GL_NOTEQUAL = $0205;
  GL_GEQUAL = $0206;
  GL_ALWAYS = $0207;
  GL_SRC_COLOR = $0300;
  GL_ONE_MINUS_SRC_COLOR = $0301;
  GL_SRC_ALPHA = $0302;
  GL_ONE_MINUS_SRC_ALPHA = $0303;
  GL_DST_ALPHA = $0304;
  GL_ONE_MINUS_DST_ALPHA = $0305;
  GL_DST_COLOR = $0306;
  GL_ONE_MINUS_DST_COLOR = $0307;
  GL_SRC_ALPHA_SATURATE = $0308;
  GL_FRONT_LEFT = $0400;
  GL_FRONT_RIGHT = $0401;
  GL_BACK_LEFT = $0402;
  GL_BACK_RIGHT = $0403;
  GL_FRONT = $0404;
  GL_BACK = $0405;
  GL_LEFT = $0406;
  GL_RIGHT = $0407;
  GL_FRONT_AND_BACK = $0408;
  GL_INVALID_ENUM = $0500;
  GL_INVALID_VALUE = $0501;
  GL_INVALID_OPERATION = $0502;
  GL_OUT_OF_MEMORY = $0505;
  GL_CW = $0900;
  GL_CCW = $0901;
  GL_POINT_SIZE = $0B11;
  GL_POINT_SIZE_RANGE = $0B12;
  GL_POINT_SIZE_GRANULARITY = $0B13;
  GL_LINE_SMOOTH = $0B20;
  GL_LINE_WIDTH = $0B21;
  GL_LINE_WIDTH_RANGE = $0B22;
  GL_LINE_WIDTH_GRANULARITY = $0B23;
  GL_POLYGON_MODE = $0B40;
  GL_POLYGON_SMOOTH = $0B41;
  GL_CULL_FACE = $0B44;
  GL_CULL_FACE_MODE = $0B45;
  GL_FRONT_FACE = $0B46;
  GL_DEPTH_RANGE = $0B70;
  GL_DEPTH_TEST = $0B71;
  GL_DEPTH_WRITEMASK = $0B72;
  GL_DEPTH_CLEAR_VALUE = $0B73;
  GL_DEPTH_FUNC = $0B74;
  GL_STENCIL_TEST = $0B90;
  GL_STENCIL_CLEAR_VALUE = $0B91;
  GL_STENCIL_FUNC = $0B92;
  GL_STENCIL_VALUE_MASK = $0B93;
  GL_STENCIL_FAIL = $0B94;
  GL_STENCIL_PASS_DEPTH_FAIL = $0B95;
  GL_STENCIL_PASS_DEPTH_PASS = $0B96;
  GL_STENCIL_REF = $0B97;
  GL_STENCIL_WRITEMASK = $0B98;
  GL_VIEWPORT = $0BA2;
  GL_DITHER = $0BD0;
  GL_BLEND_DST = $0BE0;
  GL_BLEND_SRC = $0BE1;
  GL_BLEND = $0BE2;
  GL_LOGIC_OP_MODE = $0BF0;
  GL_DRAW_BUFFER = $0C01;
  GL_READ_BUFFER = $0C02;
  GL_SCISSOR_BOX = $0C10;
  GL_SCISSOR_TEST = $0C11;
  GL_COLOR_CLEAR_VALUE = $0C22;
  GL_COLOR_WRITEMASK = $0C23;
  GL_DOUBLEBUFFER = $0C32;
  GL_STEREO = $0C33;
  GL_LINE_SMOOTH_HINT = $0C52;
  GL_POLYGON_SMOOTH_HINT = $0C53;
  GL_UNPACK_SWAP_BYTES = $0CF0;
  GL_UNPACK_LSB_FIRST = $0CF1;
  GL_UNPACK_ROW_LENGTH = $0CF2;
  GL_UNPACK_SKIP_ROWS = $0CF3;
  GL_UNPACK_SKIP_PIXELS = $0CF4;
  GL_UNPACK_ALIGNMENT = $0CF5;
  GL_PACK_SWAP_BYTES = $0D00;
  GL_PACK_LSB_FIRST = $0D01;
  GL_PACK_ROW_LENGTH = $0D02;
  GL_PACK_SKIP_ROWS = $0D03;
  GL_PACK_SKIP_PIXELS = $0D04;
  GL_PACK_ALIGNMENT = $0D05;
  GL_MAX_TEXTURE_SIZE = $0D33;
  GL_MAX_VIEWPORT_DIMS = $0D3A;
  GL_SUBPIXEL_BITS = $0D50;
  GL_TEXTURE_1D = $0DE0;
  GL_TEXTURE_2D = $0DE1;
  GL_TEXTURE_WIDTH = $1000;
  GL_TEXTURE_HEIGHT = $1001;
  GL_TEXTURE_BORDER_COLOR = $1004;
  GL_DONT_CARE = $1100;
  GL_FASTEST = $1101;
  GL_NICEST = $1102;
  GL_BYTE = $1400;
  GL_UNSIGNED_BYTE = $1401;
  GL_SHORT = $1402;
  GL_UNSIGNED_SHORT = $1403;
  GL_INT = $1404;
  GL_UNSIGNED_INT = $1405;
  GL_FLOAT = $1406;
  GL_CLEAR = $1500;
  GL_AND = $1501;
  GL_AND_REVERSE = $1502;
  GL_COPY = $1503;
  GL_AND_INVERTED = $1504;
  GL_NOOP = $1505;
  GL_XOR = $1506;
  GL_OR = $1507;
  GL_NOR = $1508;
  GL_EQUIV = $1509;
  GL_INVERT = $150A;
  GL_OR_REVERSE = $150B;
  GL_COPY_INVERTED = $150C;
  GL_OR_INVERTED = $150D;
  GL_NAND = $150E;
  GL_SET = $150F;
  GL_TEXTURE = $1702;
  GL_COLOR = $1800;
  GL_DEPTH = $1801;
  GL_STENCIL = $1802;
  GL_STENCIL_INDEX = $1901;
  GL_DEPTH_COMPONENT = $1902;
  GL_RED = $1903;
  GL_GREEN = $1904;
  GL_BLUE = $1905;
  GL_ALPHA = $1906;
  GL_RGB = $1907;
  GL_RGBA = $1908;
  GL_POINT = $1B00;
  GL_LINE = $1B01;
  GL_FILL = $1B02;
  GL_KEEP = $1E00;
  GL_REPLACE = $1E01;
  GL_INCR = $1E02;
  GL_DECR = $1E03;
  GL_VENDOR = $1F00;
  GL_RENDERER = $1F01;
  GL_VERSION = $1F02;
  GL_EXTENSIONS = $1F03;
  GL_NEAREST = $2600;
  GL_LINEAR = $2601;
  GL_NEAREST_MIPMAP_NEAREST = $2700;
  GL_LINEAR_MIPMAP_NEAREST = $2701;
  GL_NEAREST_MIPMAP_LINEAR = $2702;
  GL_LINEAR_MIPMAP_LINEAR = $2703;
  GL_TEXTURE_MAG_FILTER = $2800;
  GL_TEXTURE_MIN_FILTER = $2801;
  GL_TEXTURE_WRAP_S = $2802;
  GL_TEXTURE_WRAP_T = $2803;
  GL_REPEAT = $2901;
  GL_COLOR_LOGIC_OP = $0BF2;
  GL_POLYGON_OFFSET_UNITS = $2A00;
  GL_POLYGON_OFFSET_POINT = $2A01;
  GL_POLYGON_OFFSET_LINE = $2A02;
  GL_POLYGON_OFFSET_FILL = $8037;
  GL_POLYGON_OFFSET_FACTOR = $8038;
  GL_TEXTURE_BINDING_1D = $8068;
  GL_TEXTURE_BINDING_2D = $8069;
  GL_TEXTURE_INTERNAL_FORMAT = $1003;
  GL_TEXTURE_RED_SIZE = $805C;
  GL_TEXTURE_GREEN_SIZE = $805D;
  GL_TEXTURE_BLUE_SIZE = $805E;
  GL_TEXTURE_ALPHA_SIZE = $805F;
  GL_DOUBLE = $140A;
  GL_PROXY_TEXTURE_1D = $8063;
  GL_PROXY_TEXTURE_2D = $8064;
  GL_R3_G3_B2 = $2A10;
  GL_RGB4 = $804F;
  GL_RGB5 = $8050;
  GL_RGB8 = $8051;
  GL_RGB10 = $8052;
  GL_RGB12 = $8053;
  GL_RGB16 = $8054;
  GL_RGBA2 = $8055;
  GL_RGBA4 = $8056;
  GL_RGB5_A1 = $8057;
  GL_RGBA8 = $8058;
  GL_RGB10_A2 = $8059;
  GL_RGBA12 = $805A;
  GL_RGBA16 = $805B;
  GL_UNSIGNED_BYTE_3_3_2 = $8032;
  GL_UNSIGNED_SHORT_4_4_4_4 = $8033;
  GL_UNSIGNED_SHORT_5_5_5_1 = $8034;
  GL_UNSIGNED_INT_8_8_8_8 = $8035;
  GL_UNSIGNED_INT_10_10_10_2 = $8036;
  GL_TEXTURE_BINDING_3D = $806A;
  GL_PACK_SKIP_IMAGES = $806B;
  GL_PACK_IMAGE_HEIGHT = $806C;
  GL_UNPACK_SKIP_IMAGES = $806D;
  GL_UNPACK_IMAGE_HEIGHT = $806E;
  GL_TEXTURE_3D = $806F;
  GL_PROXY_TEXTURE_3D = $8070;
  GL_TEXTURE_DEPTH = $8071;
  GL_TEXTURE_WRAP_R = $8072;
  GL_MAX_3D_TEXTURE_SIZE = $8073;
  GL_UNSIGNED_BYTE_2_3_3_REV = $8362;
  GL_UNSIGNED_SHORT_5_6_5 = $8363;
  GL_UNSIGNED_SHORT_5_6_5_REV = $8364;
  GL_UNSIGNED_SHORT_4_4_4_4_REV = $8365;
  GL_UNSIGNED_SHORT_1_5_5_5_REV = $8366;
  GL_UNSIGNED_INT_8_8_8_8_REV = $8367;
  GL_UNSIGNED_INT_2_10_10_10_REV = $8368;
  GL_BGR = $80E0;
  GL_BGRA = $80E1;
  GL_MAX_ELEMENTS_VERTICES = $80E8;
  GL_MAX_ELEMENTS_INDICES = $80E9;
  GL_CLAMP_TO_EDGE = $812F;
  GL_TEXTURE_MIN_LOD = $813A;
  GL_TEXTURE_MAX_LOD = $813B;
  GL_TEXTURE_BASE_LEVEL = $813C;
  GL_TEXTURE_MAX_LEVEL = $813D;
  GL_SMOOTH_POINT_SIZE_RANGE = $0B12;
  GL_SMOOTH_POINT_SIZE_GRANULARITY = $0B13;
  GL_SMOOTH_LINE_WIDTH_RANGE = $0B22;
  GL_SMOOTH_LINE_WIDTH_GRANULARITY = $0B23;
  GL_ALIASED_LINE_WIDTH_RANGE = $846E;
  GL_TEXTURE0 = $84C0;
  GL_TEXTURE1 = $84C1;
  GL_TEXTURE2 = $84C2;
  GL_TEXTURE3 = $84C3;
  GL_TEXTURE4 = $84C4;
  GL_TEXTURE5 = $84C5;
  GL_TEXTURE6 = $84C6;
  GL_TEXTURE7 = $84C7;
  GL_TEXTURE8 = $84C8;
  GL_TEXTURE9 = $84C9;
  GL_TEXTURE10 = $84CA;
  GL_TEXTURE11 = $84CB;
  GL_TEXTURE12 = $84CC;
  GL_TEXTURE13 = $84CD;
  GL_TEXTURE14 = $84CE;
  GL_TEXTURE15 = $84CF;
  GL_TEXTURE16 = $84D0;
  GL_TEXTURE17 = $84D1;
  GL_TEXTURE18 = $84D2;
  GL_TEXTURE19 = $84D3;
  GL_TEXTURE20 = $84D4;
  GL_TEXTURE21 = $84D5;
  GL_TEXTURE22 = $84D6;
  GL_TEXTURE23 = $84D7;
  GL_TEXTURE24 = $84D8;
  GL_TEXTURE25 = $84D9;
  GL_TEXTURE26 = $84DA;
  GL_TEXTURE27 = $84DB;
  GL_TEXTURE28 = $84DC;
  GL_TEXTURE29 = $84DD;
  GL_TEXTURE30 = $84DE;
  GL_TEXTURE31 = $84DF;
  GL_ACTIVE_TEXTURE = $84E0;
  GL_MULTISAMPLE = $809D;
  GL_SAMPLE_ALPHA_TO_COVERAGE = $809E;
  GL_SAMPLE_ALPHA_TO_ONE = $809F;
  GL_SAMPLE_COVERAGE = $80A0;
  GL_SAMPLE_BUFFERS = $80A8;
  GL_SAMPLES = $80A9;
  GL_SAMPLE_COVERAGE_VALUE = $80AA;
  GL_SAMPLE_COVERAGE_INVERT = $80AB;
  GL_TEXTURE_CUBE_MAP = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = $851A;
  GL_PROXY_TEXTURE_CUBE_MAP = $851B;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE = $851C;
  GL_COMPRESSED_RGB = $84ED;
  GL_COMPRESSED_RGBA = $84EE;
  GL_TEXTURE_COMPRESSION_HINT = $84EF;
  GL_TEXTURE_COMPRESSED_IMAGE_SIZE = $86A0;
  GL_TEXTURE_COMPRESSED = $86A1;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS = $86A2;
  GL_COMPRESSED_TEXTURE_FORMATS = $86A3;
  GL_CLAMP_TO_BORDER = $812D;
  GL_BLEND_DST_RGB = $80C8;
  GL_BLEND_SRC_RGB = $80C9;
  GL_BLEND_DST_ALPHA = $80CA;
  GL_BLEND_SRC_ALPHA = $80CB;
  GL_POINT_FADE_THRESHOLD_SIZE = $8128;
  GL_DEPTH_COMPONENT16 = $81A5;
  GL_DEPTH_COMPONENT24 = $81A6;
  GL_DEPTH_COMPONENT32 = $81A7;
  GL_MIRRORED_REPEAT = $8370;
  GL_MAX_TEXTURE_LOD_BIAS = $84FD;
  GL_TEXTURE_LOD_BIAS = $8501;
  GL_INCR_WRAP = $8507;
  GL_DECR_WRAP = $8508;
  GL_TEXTURE_DEPTH_SIZE = $884A;
  GL_TEXTURE_COMPARE_MODE = $884C;
  GL_TEXTURE_COMPARE_FUNC = $884D;
  GL_BLEND_COLOR = $8005;
  GL_BLEND_EQUATION = $8009;
  GL_CONSTANT_COLOR = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR = $8002;
  GL_CONSTANT_ALPHA = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA = $8004;
  GL_FUNC_ADD = $8006;
  GL_FUNC_REVERSE_SUBTRACT = $800B;
  GL_FUNC_SUBTRACT = $800A;
  GL_MIN = $8007;
  GL_MAX = $8008;
  GL_BUFFER_SIZE = $8764;
  GL_BUFFER_USAGE = $8765;
  GL_QUERY_COUNTER_BITS = $8864;
  GL_CURRENT_QUERY = $8865;
  GL_QUERY_RESULT = $8866;
  GL_QUERY_RESULT_AVAILABLE = $8867;
  GL_ARRAY_BUFFER = $8892;
  GL_ELEMENT_ARRAY_BUFFER = $8893;
  GL_ARRAY_BUFFER_BINDING = $8894;
  GL_ELEMENT_ARRAY_BUFFER_BINDING = $8895;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = $889F;
  GL_READ_ONLY = $88B8;
  GL_WRITE_ONLY = $88B9;
  GL_READ_WRITE = $88BA;
  GL_BUFFER_ACCESS = $88BB;
  GL_BUFFER_MAPPED = $88BC;
  GL_BUFFER_MAP_POINTER = $88BD;
  GL_STREAM_DRAW = $88E0;
  GL_STREAM_READ = $88E1;
  GL_STREAM_COPY = $88E2;
  GL_STATIC_DRAW = $88E4;
  GL_STATIC_READ = $88E5;
  GL_STATIC_COPY = $88E6;
  GL_DYNAMIC_DRAW = $88E8;
  GL_DYNAMIC_READ = $88E9;
  GL_DYNAMIC_COPY = $88EA;
  GL_SAMPLES_PASSED = $8914;
  GL_SRC1_ALPHA = $8589;
  GL_BLEND_EQUATION_RGB = $8009;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED = $8622;
  GL_VERTEX_ATTRIB_ARRAY_SIZE = $8623;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE = $8624;
  GL_VERTEX_ATTRIB_ARRAY_TYPE = $8625;
  GL_CURRENT_VERTEX_ATTRIB = $8626;
  GL_VERTEX_PROGRAM_POINT_SIZE = $8642;
  GL_VERTEX_ATTRIB_ARRAY_POINTER = $8645;
  GL_STENCIL_BACK_FUNC = $8800;
  GL_STENCIL_BACK_FAIL = $8801;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_PASS = $8803;
  GL_MAX_DRAW_BUFFERS = $8824;
  GL_DRAW_BUFFER0 = $8825;
  GL_DRAW_BUFFER1 = $8826;
  GL_DRAW_BUFFER2 = $8827;
  GL_DRAW_BUFFER3 = $8828;
  GL_DRAW_BUFFER4 = $8829;
  GL_DRAW_BUFFER5 = $882A;
  GL_DRAW_BUFFER6 = $882B;
  GL_DRAW_BUFFER7 = $882C;
  GL_DRAW_BUFFER8 = $882D;
  GL_DRAW_BUFFER9 = $882E;
  GL_DRAW_BUFFER10 = $882F;
  GL_DRAW_BUFFER11 = $8830;
  GL_DRAW_BUFFER12 = $8831;
  GL_DRAW_BUFFER13 = $8832;
  GL_DRAW_BUFFER14 = $8833;
  GL_DRAW_BUFFER15 = $8834;
  GL_BLEND_EQUATION_ALPHA = $883D;
  GL_MAX_VERTEX_ATTRIBS = $8869;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = $886A;
  GL_MAX_TEXTURE_IMAGE_UNITS = $8872;
  GL_FRAGMENT_SHADER = $8B30;
  GL_VERTEX_SHADER = $8B31;
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = $8B49;
  GL_MAX_VERTEX_UNIFORM_COMPONENTS = $8B4A;
  GL_MAX_VARYING_FLOATS = $8B4B;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = $8B4C;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = $8B4D;
  GL_SHADER_TYPE = $8B4F;
  GL_FLOAT_VEC2 = $8B50;
  GL_FLOAT_VEC3 = $8B51;
  GL_FLOAT_VEC4 = $8B52;
  GL_INT_VEC2 = $8B53;
  GL_INT_VEC3 = $8B54;
  GL_INT_VEC4 = $8B55;
  GL_BOOL = $8B56;
  GL_BOOL_VEC2 = $8B57;
  GL_BOOL_VEC3 = $8B58;
  GL_BOOL_VEC4 = $8B59;
  GL_FLOAT_MAT2 = $8B5A;
  GL_FLOAT_MAT3 = $8B5B;
  GL_FLOAT_MAT4 = $8B5C;
  GL_SAMPLER_1D = $8B5D;
  GL_SAMPLER_2D = $8B5E;
  GL_SAMPLER_3D = $8B5F;
  GL_SAMPLER_CUBE = $8B60;
  GL_SAMPLER_1D_SHADOW = $8B61;
  GL_SAMPLER_2D_SHADOW = $8B62;
  GL_DELETE_STATUS = $8B80;
  GL_COMPILE_STATUS = $8B81;
  GL_LINK_STATUS = $8B82;
  GL_VALIDATE_STATUS = $8B83;
  GL_INFO_LOG_LENGTH = $8B84;
  GL_ATTACHED_SHADERS = $8B85;
  GL_ACTIVE_UNIFORMS = $8B86;
  GL_ACTIVE_UNIFORM_MAX_LENGTH = $8B87;
  GL_SHADER_SOURCE_LENGTH = $8B88;
  GL_ACTIVE_ATTRIBUTES = $8B89;
  GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = $8B8A;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT = $8B8B;
  GL_SHADING_LANGUAGE_VERSION = $8B8C;
  GL_CURRENT_PROGRAM = $8B8D;
  GL_POINT_SPRITE_COORD_ORIGIN = $8CA0;
  GL_LOWER_LEFT = $8CA1;
  GL_UPPER_LEFT = $8CA2;
  GL_STENCIL_BACK_REF = $8CA3;
  GL_STENCIL_BACK_VALUE_MASK = $8CA4;
  GL_STENCIL_BACK_WRITEMASK = $8CA5;
  GL_PIXEL_PACK_BUFFER = $88EB;
  GL_PIXEL_UNPACK_BUFFER = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING = $88ED;
  GL_PIXEL_UNPACK_BUFFER_BINDING = $88EF;
  GL_FLOAT_MAT2x3 = $8B65;
  GL_FLOAT_MAT2x4 = $8B66;
  GL_FLOAT_MAT3x2 = $8B67;
  GL_FLOAT_MAT3x4 = $8B68;
  GL_FLOAT_MAT4x2 = $8B69;
  GL_FLOAT_MAT4x3 = $8B6A;
  GL_SRGB = $8C40;
  GL_SRGB8 = $8C41;
  GL_SRGB_ALPHA = $8C42;
  GL_SRGB8_ALPHA8 = $8C43;
  GL_COMPRESSED_SRGB = $8C48;
  GL_COMPRESSED_SRGB_ALPHA = $8C49;
  GL_COMPARE_REF_TO_TEXTURE = $884E;
  GL_CLIP_DISTANCE0 = $3000;
  GL_CLIP_DISTANCE1 = $3001;
  GL_CLIP_DISTANCE2 = $3002;
  GL_CLIP_DISTANCE3 = $3003;
  GL_CLIP_DISTANCE4 = $3004;
  GL_CLIP_DISTANCE5 = $3005;
  GL_CLIP_DISTANCE6 = $3006;
  GL_CLIP_DISTANCE7 = $3007;
  GL_MAX_CLIP_DISTANCES = $0D32;
  GL_MAJOR_VERSION = $821B;
  GL_MINOR_VERSION = $821C;
  GL_NUM_EXTENSIONS = $821D;
  GL_CONTEXT_FLAGS = $821E;
  GL_COMPRESSED_RED = $8225;
  GL_COMPRESSED_RG = $8226;
  GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = $00000001;
  GL_RGBA32F = $8814;
  GL_RGB32F = $8815;
  GL_RGBA16F = $881A;
  GL_RGB16F = $881B;
  GL_VERTEX_ATTRIB_ARRAY_INTEGER = $88FD;
  GL_MAX_ARRAY_TEXTURE_LAYERS = $88FF;
  GL_MIN_PROGRAM_TEXEL_OFFSET = $8904;
  GL_MAX_PROGRAM_TEXEL_OFFSET = $8905;
  GL_CLAMP_READ_COLOR = $891C;
  GL_FIXED_ONLY = $891D;
  GL_MAX_VARYING_COMPONENTS = $8B4B;
  GL_TEXTURE_1D_ARRAY = $8C18;
  GL_PROXY_TEXTURE_1D_ARRAY = $8C19;
  GL_TEXTURE_2D_ARRAY = $8C1A;
  GL_PROXY_TEXTURE_2D_ARRAY = $8C1B;
  GL_TEXTURE_BINDING_1D_ARRAY = $8C1C;
  GL_TEXTURE_BINDING_2D_ARRAY = $8C1D;
  GL_R11F_G11F_B10F = $8C3A;
  GL_UNSIGNED_INT_10F_11F_11F_REV = $8C3B;
  GL_RGB9_E5 = $8C3D;
  GL_UNSIGNED_INT_5_9_9_9_REV = $8C3E;
  GL_TEXTURE_SHARED_SIZE = $8C3F;
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = $8C76;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE = $8C7F;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = $8C80;
  GL_TRANSFORM_FEEDBACK_VARYINGS = $8C83;
  GL_TRANSFORM_FEEDBACK_BUFFER_START = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = $8C85;
  GL_PRIMITIVES_GENERATED = $8C87;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = $8C88;
  GL_RASTERIZER_DISCARD = $8C89;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = $8C8B;
  GL_INTERLEAVED_ATTRIBS = $8C8C;
  GL_SEPARATE_ATTRIBS = $8C8D;
  GL_TRANSFORM_FEEDBACK_BUFFER = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = $8C8F;
  GL_RGBA32UI = $8D70;
  GL_RGB32UI = $8D71;
  GL_RGBA16UI = $8D76;
  GL_RGB16UI = $8D77;
  GL_RGBA8UI = $8D7C;
  GL_RGB8UI = $8D7D;
  GL_RGBA32I = $8D82;
  GL_RGB32I = $8D83;
  GL_RGBA16I = $8D88;
  GL_RGB16I = $8D89;
  GL_RGBA8I = $8D8E;
  GL_RGB8I = $8D8F;
  GL_RED_INTEGER = $8D94;
  GL_GREEN_INTEGER = $8D95;
  GL_BLUE_INTEGER = $8D96;
  GL_RGB_INTEGER = $8D98;
  GL_RGBA_INTEGER = $8D99;
  GL_BGR_INTEGER = $8D9A;
  GL_BGRA_INTEGER = $8D9B;
  GL_SAMPLER_1D_ARRAY = $8DC0;
  GL_SAMPLER_2D_ARRAY = $8DC1;
  GL_SAMPLER_1D_ARRAY_SHADOW = $8DC3;
  GL_SAMPLER_2D_ARRAY_SHADOW = $8DC4;
  GL_SAMPLER_CUBE_SHADOW = $8DC5;
  GL_UNSIGNED_INT_VEC2 = $8DC6;
  GL_UNSIGNED_INT_VEC3 = $8DC7;
  GL_UNSIGNED_INT_VEC4 = $8DC8;
  GL_INT_SAMPLER_1D = $8DC9;
  GL_INT_SAMPLER_2D = $8DCA;
  GL_INT_SAMPLER_3D = $8DCB;
  GL_INT_SAMPLER_CUBE = $8DCC;
  GL_INT_SAMPLER_1D_ARRAY = $8DCE;
  GL_INT_SAMPLER_2D_ARRAY = $8DCF;
  GL_UNSIGNED_INT_SAMPLER_1D = $8DD1;
  GL_UNSIGNED_INT_SAMPLER_2D = $8DD2;
  GL_UNSIGNED_INT_SAMPLER_3D = $8DD3;
  GL_UNSIGNED_INT_SAMPLER_CUBE = $8DD4;
  GL_UNSIGNED_INT_SAMPLER_1D_ARRAY = $8DD6;
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = $8DD7;
  GL_QUERY_WAIT = $8E13;
  GL_QUERY_NO_WAIT = $8E14;
  GL_QUERY_BY_REGION_WAIT = $8E15;
  GL_QUERY_BY_REGION_NO_WAIT = $8E16;
  GL_BUFFER_ACCESS_FLAGS = $911F;
  GL_BUFFER_MAP_LENGTH = $9120;
  GL_BUFFER_MAP_OFFSET = $9121;
  GL_DEPTH_COMPONENT32F = $8CAC;
  GL_DEPTH32F_STENCIL8 = $8CAD;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV = $8DAD;
  GL_INVALID_FRAMEBUFFER_OPERATION = $0506;
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = $8210;
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = $8211;
  GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = $8212;
  GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = $8213;
  GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = $8214;
  GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = $8215;
  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = $8216;
  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = $8217;
  GL_FRAMEBUFFER_DEFAULT = $8218;
  GL_FRAMEBUFFER_UNDEFINED = $8219;
  GL_DEPTH_STENCIL_ATTACHMENT = $821A;
  GL_MAX_RENDERBUFFER_SIZE = $84E8;
  GL_DEPTH_STENCIL = $84F9;
  GL_UNSIGNED_INT_24_8 = $84FA;
  GL_DEPTH24_STENCIL8 = $88F0;
  GL_TEXTURE_STENCIL_SIZE = $88F1;
  GL_TEXTURE_RED_TYPE = $8C10;
  GL_TEXTURE_GREEN_TYPE = $8C11;
  GL_TEXTURE_BLUE_TYPE = $8C12;
  GL_TEXTURE_ALPHA_TYPE = $8C13;
  GL_TEXTURE_DEPTH_TYPE = $8C16;
  GL_UNSIGNED_NORMALIZED = $8C17;
  GL_FRAMEBUFFER_BINDING = $8CA6;
  GL_DRAW_FRAMEBUFFER_BINDING = $8CA6;
  GL_RENDERBUFFER_BINDING = $8CA7;
  GL_READ_FRAMEBUFFER = $8CA8;
  GL_DRAW_FRAMEBUFFER = $8CA9;
  GL_READ_FRAMEBUFFER_BINDING = $8CAA;
  GL_RENDERBUFFER_SAMPLES = $8CAB;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = $8CD3;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = $8CD4;
  GL_FRAMEBUFFER_COMPLETE = $8CD5;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = $8CDB;
  GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = $8CDC;
  GL_FRAMEBUFFER_UNSUPPORTED = $8CDD;
  GL_MAX_COLOR_ATTACHMENTS = $8CDF;
  GL_COLOR_ATTACHMENT0 = $8CE0;
  GL_COLOR_ATTACHMENT1 = $8CE1;
  GL_COLOR_ATTACHMENT2 = $8CE2;
  GL_COLOR_ATTACHMENT3 = $8CE3;
  GL_COLOR_ATTACHMENT4 = $8CE4;
  GL_COLOR_ATTACHMENT5 = $8CE5;
  GL_COLOR_ATTACHMENT6 = $8CE6;
  GL_COLOR_ATTACHMENT7 = $8CE7;
  GL_COLOR_ATTACHMENT8 = $8CE8;
  GL_COLOR_ATTACHMENT9 = $8CE9;
  GL_COLOR_ATTACHMENT10 = $8CEA;
  GL_COLOR_ATTACHMENT11 = $8CEB;
  GL_COLOR_ATTACHMENT12 = $8CEC;
  GL_COLOR_ATTACHMENT13 = $8CED;
  GL_COLOR_ATTACHMENT14 = $8CEE;
  GL_COLOR_ATTACHMENT15 = $8CEF;
  GL_COLOR_ATTACHMENT16 = $8CF0;
  GL_COLOR_ATTACHMENT17 = $8CF1;
  GL_COLOR_ATTACHMENT18 = $8CF2;
  GL_COLOR_ATTACHMENT19 = $8CF3;
  GL_COLOR_ATTACHMENT20 = $8CF4;
  GL_COLOR_ATTACHMENT21 = $8CF5;
  GL_COLOR_ATTACHMENT22 = $8CF6;
  GL_COLOR_ATTACHMENT23 = $8CF7;
  GL_COLOR_ATTACHMENT24 = $8CF8;
  GL_COLOR_ATTACHMENT25 = $8CF9;
  GL_COLOR_ATTACHMENT26 = $8CFA;
  GL_COLOR_ATTACHMENT27 = $8CFB;
  GL_COLOR_ATTACHMENT28 = $8CFC;
  GL_COLOR_ATTACHMENT29 = $8CFD;
  GL_COLOR_ATTACHMENT30 = $8CFE;
  GL_COLOR_ATTACHMENT31 = $8CFF;
  GL_DEPTH_ATTACHMENT = $8D00;
  GL_STENCIL_ATTACHMENT = $8D20;
  GL_FRAMEBUFFER = $8D40;
  GL_RENDERBUFFER = $8D41;
  GL_RENDERBUFFER_WIDTH = $8D42;
  GL_RENDERBUFFER_HEIGHT = $8D43;
  GL_RENDERBUFFER_INTERNAL_FORMAT = $8D44;
  GL_STENCIL_INDEX1 = $8D46;
  GL_STENCIL_INDEX4 = $8D47;
  GL_STENCIL_INDEX8 = $8D48;
  GL_STENCIL_INDEX16 = $8D49;
  GL_RENDERBUFFER_RED_SIZE = $8D50;
  GL_RENDERBUFFER_GREEN_SIZE = $8D51;
  GL_RENDERBUFFER_BLUE_SIZE = $8D52;
  GL_RENDERBUFFER_ALPHA_SIZE = $8D53;
  GL_RENDERBUFFER_DEPTH_SIZE = $8D54;
  GL_RENDERBUFFER_STENCIL_SIZE = $8D55;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = $8D56;
  GL_MAX_SAMPLES = $8D57;
  GL_FRAMEBUFFER_SRGB = $8DB9;
  GL_HALF_FLOAT = $140B;
  GL_MAP_READ_BIT = $0001;
  GL_MAP_WRITE_BIT = $0002;
  GL_MAP_INVALIDATE_RANGE_BIT = $0004;
  GL_MAP_INVALIDATE_BUFFER_BIT = $0008;
  GL_MAP_FLUSH_EXPLICIT_BIT = $0010;
  GL_MAP_UNSYNCHRONIZED_BIT = $0020;
  GL_COMPRESSED_RED_RGTC1 = $8DBB;
  GL_COMPRESSED_SIGNED_RED_RGTC1 = $8DBC;
  GL_COMPRESSED_RG_RGTC2 = $8DBD;
  GL_COMPRESSED_SIGNED_RG_RGTC2 = $8DBE;
  GL_RG = $8227;
  GL_RG_INTEGER = $8228;
  GL_R8 = $8229;
  GL_R16 = $822A;
  GL_RG8 = $822B;
  GL_RG16 = $822C;
  GL_R16F = $822D;
  GL_R32F = $822E;
  GL_RG16F = $822F;
  GL_RG32F = $8230;
  GL_R8I = $8231;
  GL_R8UI = $8232;
  GL_R16I = $8233;
  GL_R16UI = $8234;
  GL_R32I = $8235;
  GL_R32UI = $8236;
  GL_RG8I = $8237;
  GL_RG8UI = $8238;
  GL_RG16I = $8239;
  GL_RG16UI = $823A;
  GL_RG32I = $823B;
  GL_RG32UI = $823C;
  GL_VERTEX_ARRAY_BINDING = $85B5;
  GL_SAMPLER_2D_RECT = $8B63;
  GL_SAMPLER_2D_RECT_SHADOW = $8B64;
  GL_SAMPLER_BUFFER = $8DC2;
  GL_INT_SAMPLER_2D_RECT = $8DCD;
  GL_INT_SAMPLER_BUFFER = $8DD0;
  GL_UNSIGNED_INT_SAMPLER_2D_RECT = $8DD5;
  GL_UNSIGNED_INT_SAMPLER_BUFFER = $8DD8;
  GL_TEXTURE_BUFFER = $8C2A;
  GL_MAX_TEXTURE_BUFFER_SIZE = $8C2B;
  GL_TEXTURE_BINDING_BUFFER = $8C2C;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING = $8C2D;
  GL_TEXTURE_RECTANGLE = $84F5;
  GL_TEXTURE_BINDING_RECTANGLE = $84F6;
  GL_PROXY_TEXTURE_RECTANGLE = $84F7;
  GL_MAX_RECTANGLE_TEXTURE_SIZE = $84F8;
  GL_R8_SNORM = $8F94;
  GL_RG8_SNORM = $8F95;
  GL_RGB8_SNORM = $8F96;
  GL_RGBA8_SNORM = $8F97;
  GL_R16_SNORM = $8F98;
  GL_RG16_SNORM = $8F99;
  GL_RGB16_SNORM = $8F9A;
  GL_RGBA16_SNORM = $8F9B;
  GL_SIGNED_NORMALIZED = $8F9C;
  GL_PRIMITIVE_RESTART = $8F9D;
  GL_PRIMITIVE_RESTART_INDEX = $8F9E;
  GL_COPY_READ_BUFFER = $8F36;
  GL_COPY_WRITE_BUFFER = $8F37;
  GL_UNIFORM_BUFFER = $8A11;
  GL_UNIFORM_BUFFER_BINDING = $8A28;
  GL_UNIFORM_BUFFER_START = $8A29;
  GL_UNIFORM_BUFFER_SIZE = $8A2A;
  GL_MAX_VERTEX_UNIFORM_BLOCKS = $8A2B;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS = $8A2C;
  GL_MAX_FRAGMENT_UNIFORM_BLOCKS = $8A2D;
  GL_MAX_COMBINED_UNIFORM_BLOCKS = $8A2E;
  GL_MAX_UNIFORM_BUFFER_BINDINGS = $8A2F;
  GL_MAX_UNIFORM_BLOCK_SIZE = $8A30;
  GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = $8A31;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = $8A32;
  GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = $8A33;
  GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = $8A34;
  GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = $8A35;
  GL_ACTIVE_UNIFORM_BLOCKS = $8A36;
  GL_UNIFORM_TYPE = $8A37;
  GL_UNIFORM_SIZE = $8A38;
  GL_UNIFORM_NAME_LENGTH = $8A39;
  GL_UNIFORM_BLOCK_INDEX = $8A3A;
  GL_UNIFORM_OFFSET = $8A3B;
  GL_UNIFORM_ARRAY_STRIDE = $8A3C;
  GL_UNIFORM_MATRIX_STRIDE = $8A3D;
  GL_UNIFORM_IS_ROW_MAJOR = $8A3E;
  GL_UNIFORM_BLOCK_BINDING = $8A3F;
  GL_UNIFORM_BLOCK_DATA_SIZE = $8A40;
  GL_UNIFORM_BLOCK_NAME_LENGTH = $8A41;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = $8A42;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = $8A43;
  GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = $8A44;
  GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = $8A45;
  GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = $8A46;
  GL_CONTEXT_CORE_PROFILE_BIT = $00000001;
  GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = $00000002;
  GL_LINES_ADJACENCY = $000A;
  GL_LINE_STRIP_ADJACENCY = $000B;
  GL_TRIANGLES_ADJACENCY = $000C;
  GL_TRIANGLE_STRIP_ADJACENCY = $000D;
  GL_PROGRAM_POINT_SIZE = $8642;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = $8C29;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED = $8DA7;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = $8DA8;
  GL_GEOMETRY_SHADER = $8DD9;
  GL_GEOMETRY_VERTICES_OUT = $8916;
  GL_GEOMETRY_INPUT_TYPE = $8917;
  GL_GEOMETRY_OUTPUT_TYPE = $8918;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = $8DDF;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES = $8DE0;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = $8DE1;
  GL_MAX_VERTEX_OUTPUT_COMPONENTS = $9122;
  GL_MAX_GEOMETRY_INPUT_COMPONENTS = $9123;
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = $9124;
  GL_MAX_FRAGMENT_INPUT_COMPONENTS = $9125;
  GL_CONTEXT_PROFILE_MASK = $9126;
  GL_DEPTH_CLAMP = $864F;
  GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = $8E4C;
  GL_FIRST_VERTEX_CONVENTION = $8E4D;
  GL_LAST_VERTEX_CONVENTION = $8E4E;
  GL_PROVOKING_VERTEX = $8E4F;
  GL_TEXTURE_CUBE_MAP_SEAMLESS = $884F;
  GL_MAX_SERVER_WAIT_TIMEOUT = $9111;
  GL_OBJECT_TYPE = $9112;
  GL_SYNC_CONDITION = $9113;
  GL_SYNC_STATUS = $9114;
  GL_SYNC_FLAGS = $9115;
  GL_SYNC_FENCE = $9116;
  GL_SYNC_GPU_COMMANDS_COMPLETE = $9117;
  GL_UNSIGNALED = $9118;
  GL_SIGNALED = $9119;
  GL_ALREADY_SIGNALED = $911A;
  GL_TIMEOUT_EXPIRED = $911B;
  GL_CONDITION_SATISFIED = $911C;
  GL_WAIT_FAILED = $911D;
  GL_SYNC_FLUSH_COMMANDS_BIT = $00000001;
  GL_SAMPLE_POSITION = $8E50;
  GL_SAMPLE_MASK = $8E51;
  GL_SAMPLE_MASK_VALUE = $8E52;
  GL_MAX_SAMPLE_MASK_WORDS = $8E59;
  GL_TEXTURE_2D_MULTISAMPLE = $9100;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE = $9101;
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY = $9102;
  GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = $9103;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE = $9104;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = $9105;
  GL_TEXTURE_SAMPLES = $9106;
  GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = $9107;
  GL_SAMPLER_2D_MULTISAMPLE = $9108;
  GL_INT_SAMPLER_2D_MULTISAMPLE = $9109;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = $910A;
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY = $910B;
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910C;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = $910D;
  GL_MAX_COLOR_TEXTURE_SAMPLES = $910E;
  GL_MAX_DEPTH_TEXTURE_SAMPLES = $910F;
  GL_MAX_INTEGER_SAMPLES = $9110;
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR = $88FE;
  GL_SRC1_COLOR = $88F9;
  GL_ONE_MINUS_SRC1_COLOR = $88FA;
  GL_ONE_MINUS_SRC1_ALPHA = $88FB;
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = $88FC;
  GL_ANY_SAMPLES_PASSED = $8C2F;
  GL_SAMPLER_BINDING = $8919;
  GL_RGB10_A2UI = $906F;
  GL_TEXTURE_SWIZZLE_R = $8E42;
  GL_TEXTURE_SWIZZLE_G = $8E43;
  GL_TEXTURE_SWIZZLE_B = $8E44;
  GL_TEXTURE_SWIZZLE_A = $8E45;
  GL_TEXTURE_SWIZZLE_RGBA = $8E46;
  GL_TIME_ELAPSED = $88BF;
  GL_TIMESTAMP = $8E28;
  GL_INT_2_10_10_10_REV = $8D9F;
  GL_SAMPLE_SHADING = $8C36;
  GL_MIN_SAMPLE_SHADING_VALUE = $8C37;
  GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = $8E5E;
  GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = $8E5F;
  GL_TEXTURE_CUBE_MAP_ARRAY = $9009;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = $900A;
  GL_PROXY_TEXTURE_CUBE_MAP_ARRAY = $900B;
  GL_SAMPLER_CUBE_MAP_ARRAY = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW = $900D;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY = $900E;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = $900F;
  GL_DRAW_INDIRECT_BUFFER = $8F3F;
  GL_DRAW_INDIRECT_BUFFER_BINDING = $8F43;
  GL_GEOMETRY_SHADER_INVOCATIONS = $887F;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS = $8E5A;
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = $8E5B;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = $8E5C;
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = $8E5D;
  GL_MAX_VERTEX_STREAMS = $8E71;
  GL_DOUBLE_VEC2 = $8FFC;
  GL_DOUBLE_VEC3 = $8FFD;
  GL_DOUBLE_VEC4 = $8FFE;
  GL_DOUBLE_MAT2 = $8F46;
  GL_DOUBLE_MAT3 = $8F47;
  GL_DOUBLE_MAT4 = $8F48;
  GL_DOUBLE_MAT2x3 = $8F49;
  GL_DOUBLE_MAT2x4 = $8F4A;
  GL_DOUBLE_MAT3x2 = $8F4B;
  GL_DOUBLE_MAT3x4 = $8F4C;
  GL_DOUBLE_MAT4x2 = $8F4D;
  GL_DOUBLE_MAT4x3 = $8F4E;
  GL_ACTIVE_SUBROUTINES = $8DE5;
  GL_ACTIVE_SUBROUTINE_UNIFORMS = $8DE6;
  GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = $8E47;
  GL_ACTIVE_SUBROUTINE_MAX_LENGTH = $8E48;
  GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = $8E49;
  GL_MAX_SUBROUTINES = $8DE7;
  GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = $8DE8;
  GL_NUM_COMPATIBLE_SUBROUTINES = $8E4A;
  GL_COMPATIBLE_SUBROUTINES = $8E4B;
  GL_PATCHES = $000E;
  GL_PATCH_VERTICES = $8E72;
  GL_PATCH_DEFAULT_INNER_LEVEL = $8E73;
  GL_PATCH_DEFAULT_OUTER_LEVEL = $8E74;
  GL_TESS_CONTROL_OUTPUT_VERTICES = $8E75;
  GL_TESS_GEN_MODE = $8E76;
  GL_TESS_GEN_SPACING = $8E77;
  GL_TESS_GEN_VERTEX_ORDER = $8E78;
  GL_TESS_GEN_POINT_MODE = $8E79;
  GL_ISOLINES = $8E7A;
  GL_QUADS = $0007;
  GL_FRACTIONAL_ODD = $8E7B;
  GL_FRACTIONAL_EVEN = $8E7C;
  GL_MAX_PATCH_VERTICES = $8E7D;
  GL_MAX_TESS_GEN_LEVEL = $8E7E;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = $8E7F;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E80;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = $8E81;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = $8E82;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = $8E83;
  GL_MAX_TESS_PATCH_COMPONENTS = $8E84;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = $8E85;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = $8E86;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = $8E89;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = $8E8A;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = $886C;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = $886D;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = $8E1E;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = $8E1F;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = $84F0;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = $84F1;
  GL_TESS_EVALUATION_SHADER = $8E87;
  GL_TESS_CONTROL_SHADER = $8E88;
  GL_TRANSFORM_FEEDBACK = $8E22;
  GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = $8E23;
  GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_BINDING = $8E25;
  GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = $8E70;
  GL_FIXED = $140C;
  GL_IMPLEMENTATION_COLOR_READ_TYPE = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT = $8B9B;
  GL_LOW_FLOAT = $8DF0;
  GL_MEDIUM_FLOAT = $8DF1;
  GL_HIGH_FLOAT = $8DF2;
  GL_LOW_INT = $8DF3;
  GL_MEDIUM_INT = $8DF4;
  GL_HIGH_INT = $8DF5;
  GL_SHADER_COMPILER = $8DFA;
  GL_SHADER_BINARY_FORMATS = $8DF8;
  GL_NUM_SHADER_BINARY_FORMATS = $8DF9;
  GL_MAX_VERTEX_UNIFORM_VECTORS = $8DFB;
  GL_MAX_VARYING_VECTORS = $8DFC;
  GL_MAX_FRAGMENT_UNIFORM_VECTORS = $8DFD;
  GL_RGB565 = $8D62;
  GL_PROGRAM_BINARY_RETRIEVABLE_HINT = $8257;
  GL_PROGRAM_BINARY_LENGTH = $8741;
  GL_NUM_PROGRAM_BINARY_FORMATS = $87FE;
  GL_PROGRAM_BINARY_FORMATS = $87FF;
  GL_VERTEX_SHADER_BIT = $00000001;
  GL_FRAGMENT_SHADER_BIT = $00000002;
  GL_GEOMETRY_SHADER_BIT = $00000004;
  GL_TESS_CONTROL_SHADER_BIT = $00000008;
  GL_TESS_EVALUATION_SHADER_BIT = $00000010;
  GL_ALL_SHADER_BITS = $FFFFFFFF;
  GL_PROGRAM_SEPARABLE = $8258;
  GL_ACTIVE_PROGRAM = $8259;
  GL_PROGRAM_PIPELINE_BINDING = $825A;
  GL_MAX_VIEWPORTS = $825B;
  GL_VIEWPORT_SUBPIXEL_BITS = $825C;
  GL_VIEWPORT_BOUNDS_RANGE = $825D;
  GL_LAYER_PROVOKING_VERTEX = $825E;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX = $825F;
  GL_UNDEFINED_VERTEX = $8260;
  GL_COPY_READ_BUFFER_BINDING = $8F36;
  GL_COPY_WRITE_BUFFER_BINDING = $8F37;
  GL_TRANSFORM_FEEDBACK_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_PAUSED = $8E23;
  GL_UNPACK_COMPRESSED_BLOCK_WIDTH = $9127;
  GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = $9128;
  GL_UNPACK_COMPRESSED_BLOCK_DEPTH = $9129;
  GL_UNPACK_COMPRESSED_BLOCK_SIZE = $912A;
  GL_PACK_COMPRESSED_BLOCK_WIDTH = $912B;
  GL_PACK_COMPRESSED_BLOCK_HEIGHT = $912C;
  GL_PACK_COMPRESSED_BLOCK_DEPTH = $912D;
  GL_PACK_COMPRESSED_BLOCK_SIZE = $912E;
  GL_NUM_SAMPLE_COUNTS = $9380;
  GL_MIN_MAP_BUFFER_ALIGNMENT = $90BC;
  GL_ATOMIC_COUNTER_BUFFER = $92C0;
  GL_ATOMIC_COUNTER_BUFFER_BINDING = $92C1;
  GL_ATOMIC_COUNTER_BUFFER_START = $92C2;
  GL_ATOMIC_COUNTER_BUFFER_SIZE = $92C3;
  GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = $92C4;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = $92C5;
  GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = $92C6;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = $92C7;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = $92C8;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = $92C9;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = $92CA;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = $92CB;
  GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = $92CC;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = $92CD;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = $92CE;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = $92CF;
  GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = $92D0;
  GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = $92D1;
  GL_MAX_VERTEX_ATOMIC_COUNTERS = $92D2;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = $92D3;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = $92D4;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS = $92D5;
  GL_MAX_FRAGMENT_ATOMIC_COUNTERS = $92D6;
  GL_MAX_COMBINED_ATOMIC_COUNTERS = $92D7;
  GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = $92D8;
  GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = $92DC;
  GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = $92D9;
  GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = $92DA;
  GL_UNSIGNED_INT_ATOMIC_COUNTER = $92DB;
  GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = $00000001;
  GL_ELEMENT_ARRAY_BARRIER_BIT = $00000002;
  GL_UNIFORM_BARRIER_BIT = $00000004;
  GL_TEXTURE_FETCH_BARRIER_BIT = $00000008;
  GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = $00000020;
  GL_COMMAND_BARRIER_BIT = $00000040;
  GL_PIXEL_BUFFER_BARRIER_BIT = $00000080;
  GL_TEXTURE_UPDATE_BARRIER_BIT = $00000100;
  GL_BUFFER_UPDATE_BARRIER_BIT = $00000200;
  GL_FRAMEBUFFER_BARRIER_BIT = $00000400;
  GL_TRANSFORM_FEEDBACK_BARRIER_BIT = $00000800;
  GL_ATOMIC_COUNTER_BARRIER_BIT = $00001000;
  GL_ALL_BARRIER_BITS = $FFFFFFFF;
  GL_MAX_IMAGE_UNITS = $8F38;
  GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = $8F39;
  GL_IMAGE_BINDING_NAME = $8F3A;
  GL_IMAGE_BINDING_LEVEL = $8F3B;
  GL_IMAGE_BINDING_LAYERED = $8F3C;
  GL_IMAGE_BINDING_LAYER = $8F3D;
  GL_IMAGE_BINDING_ACCESS = $8F3E;
  GL_IMAGE_1D = $904C;
  GL_IMAGE_2D = $904D;
  GL_IMAGE_3D = $904E;
  GL_IMAGE_2D_RECT = $904F;
  GL_IMAGE_CUBE = $9050;
  GL_IMAGE_BUFFER = $9051;
  GL_IMAGE_1D_ARRAY = $9052;
  GL_IMAGE_2D_ARRAY = $9053;
  GL_IMAGE_CUBE_MAP_ARRAY = $9054;
  GL_IMAGE_2D_MULTISAMPLE = $9055;
  GL_IMAGE_2D_MULTISAMPLE_ARRAY = $9056;
  GL_INT_IMAGE_1D = $9057;
  GL_INT_IMAGE_2D = $9058;
  GL_INT_IMAGE_3D = $9059;
  GL_INT_IMAGE_2D_RECT = $905A;
  GL_INT_IMAGE_CUBE = $905B;
  GL_INT_IMAGE_BUFFER = $905C;
  GL_INT_IMAGE_1D_ARRAY = $905D;
  GL_INT_IMAGE_2D_ARRAY = $905E;
  GL_INT_IMAGE_CUBE_MAP_ARRAY = $905F;
  GL_INT_IMAGE_2D_MULTISAMPLE = $9060;
  GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $9061;
  GL_UNSIGNED_INT_IMAGE_1D = $9062;
  GL_UNSIGNED_INT_IMAGE_2D = $9063;
  GL_UNSIGNED_INT_IMAGE_3D = $9064;
  GL_UNSIGNED_INT_IMAGE_2D_RECT = $9065;
  GL_UNSIGNED_INT_IMAGE_CUBE = $9066;
  GL_UNSIGNED_INT_IMAGE_BUFFER = $9067;
  GL_UNSIGNED_INT_IMAGE_1D_ARRAY = $9068;
  GL_UNSIGNED_INT_IMAGE_2D_ARRAY = $9069;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = $906A;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = $906B;
  GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = $906C;
  GL_MAX_IMAGE_SAMPLES = $906D;
  GL_IMAGE_BINDING_FORMAT = $906E;
  GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = $90C7;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = $90C8;
  GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = $90C9;
  GL_MAX_VERTEX_IMAGE_UNIFORMS = $90CA;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = $90CB;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = $90CC;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS = $90CD;
  GL_MAX_FRAGMENT_IMAGE_UNIFORMS = $90CE;
  GL_MAX_COMBINED_IMAGE_UNIFORMS = $90CF;
  GL_COMPRESSED_RGBA_BPTC_UNORM = $8E8C;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = $8E8D;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = $8E8E;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = $8E8F;
  GL_TEXTURE_IMMUTABLE_FORMAT = $912F;
  GL_NUM_SHADING_LANGUAGE_VERSIONS = $82E9;
  GL_VERTEX_ATTRIB_ARRAY_LONG = $874E;
  GL_COMPRESSED_RGB8_ETC2 = $9274;
  GL_COMPRESSED_SRGB8_ETC2 = $9275;
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9276;
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9277;
  GL_COMPRESSED_RGBA8_ETC2_EAC = $9278;
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = $9279;
  GL_COMPRESSED_R11_EAC = $9270;
  GL_COMPRESSED_SIGNED_R11_EAC = $9271;
  GL_COMPRESSED_RG11_EAC = $9272;
  GL_COMPRESSED_SIGNED_RG11_EAC = $9273;
  GL_PRIMITIVE_RESTART_FIXED_INDEX = $8D69;
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE = $8D6A;
  GL_MAX_ELEMENT_INDEX = $8D6B;
  GL_COMPUTE_SHADER = $91B9;
  GL_MAX_COMPUTE_UNIFORM_BLOCKS = $91BB;
  GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = $91BC;
  GL_MAX_COMPUTE_IMAGE_UNIFORMS = $91BD;
  GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = $8262;
  GL_MAX_COMPUTE_UNIFORM_COMPONENTS = $8263;
  GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = $8264;
  GL_MAX_COMPUTE_ATOMIC_COUNTERS = $8265;
  GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = $8266;
  GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = $90EB;
  GL_MAX_COMPUTE_WORK_GROUP_COUNT = $91BE;
  GL_MAX_COMPUTE_WORK_GROUP_SIZE = $91BF;
  GL_COMPUTE_WORK_GROUP_SIZE = $8267;
  GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = $90EC;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = $90ED;
  GL_DISPATCH_INDIRECT_BUFFER = $90EE;
  GL_DISPATCH_INDIRECT_BUFFER_BINDING = $90EF;
  GL_COMPUTE_SHADER_BIT = $00000020;
  GL_DEBUG_OUTPUT_SYNCHRONOUS = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = $8243;
  GL_DEBUG_CALLBACK_FUNCTION = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM = $8245;
  GL_DEBUG_SOURCE_API = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY = $8249;
  GL_DEBUG_SOURCE_APPLICATION = $824A;
  GL_DEBUG_SOURCE_OTHER = $824B;
  GL_DEBUG_TYPE_ERROR = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = $824E;
  GL_DEBUG_TYPE_PORTABILITY = $824F;
  GL_DEBUG_TYPE_PERFORMANCE = $8250;
  GL_DEBUG_TYPE_OTHER = $8251;
  GL_MAX_DEBUG_MESSAGE_LENGTH = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES = $9144;
  GL_DEBUG_LOGGED_MESSAGES = $9145;
  GL_DEBUG_SEVERITY_HIGH = $9146;
  GL_DEBUG_SEVERITY_MEDIUM = $9147;
  GL_DEBUG_SEVERITY_LOW = $9148;
  GL_DEBUG_TYPE_MARKER = $8268;
  GL_DEBUG_TYPE_PUSH_GROUP = $8269;
  GL_DEBUG_TYPE_POP_GROUP = $826A;
  GL_DEBUG_SEVERITY_NOTIFICATION = $826B;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH = $826C;
  GL_DEBUG_GROUP_STACK_DEPTH = $826D;
  GL_BUFFER = $82E0;
  GL_SHADER = $82E1;
  GL_PROGRAM = $82E2;
  GL_VERTEX_ARRAY = $8074;
  GL_QUERY = $82E3;
  GL_PROGRAM_PIPELINE = $82E4;
  GL_SAMPLER = $82E6;
  GL_MAX_LABEL_LENGTH = $82E8;
  GL_DEBUG_OUTPUT = $92E0;
  GL_CONTEXT_FLAG_DEBUG_BIT = $00000002;
  GL_MAX_UNIFORM_LOCATIONS = $826E;
  GL_FRAMEBUFFER_DEFAULT_WIDTH = $9310;
  GL_FRAMEBUFFER_DEFAULT_HEIGHT = $9311;
  GL_FRAMEBUFFER_DEFAULT_LAYERS = $9312;
  GL_FRAMEBUFFER_DEFAULT_SAMPLES = $9313;
  GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = $9314;
  GL_MAX_FRAMEBUFFER_WIDTH = $9315;
  GL_MAX_FRAMEBUFFER_HEIGHT = $9316;
  GL_MAX_FRAMEBUFFER_LAYERS = $9317;
  GL_MAX_FRAMEBUFFER_SAMPLES = $9318;
  GL_INTERNALFORMAT_SUPPORTED = $826F;
  GL_INTERNALFORMAT_PREFERRED = $8270;
  GL_INTERNALFORMAT_RED_SIZE = $8271;
  GL_INTERNALFORMAT_GREEN_SIZE = $8272;
  GL_INTERNALFORMAT_BLUE_SIZE = $8273;
  GL_INTERNALFORMAT_ALPHA_SIZE = $8274;
  GL_INTERNALFORMAT_DEPTH_SIZE = $8275;
  GL_INTERNALFORMAT_STENCIL_SIZE = $8276;
  GL_INTERNALFORMAT_SHARED_SIZE = $8277;
  GL_INTERNALFORMAT_RED_TYPE = $8278;
  GL_INTERNALFORMAT_GREEN_TYPE = $8279;
  GL_INTERNALFORMAT_BLUE_TYPE = $827A;
  GL_INTERNALFORMAT_ALPHA_TYPE = $827B;
  GL_INTERNALFORMAT_DEPTH_TYPE = $827C;
  GL_INTERNALFORMAT_STENCIL_TYPE = $827D;
  GL_MAX_WIDTH = $827E;
  GL_MAX_HEIGHT = $827F;
  GL_MAX_DEPTH = $8280;
  GL_MAX_LAYERS = $8281;
  GL_MAX_COMBINED_DIMENSIONS = $8282;
  GL_COLOR_COMPONENTS = $8283;
  GL_DEPTH_COMPONENTS = $8284;
  GL_STENCIL_COMPONENTS = $8285;
  GL_COLOR_RENDERABLE = $8286;
  GL_DEPTH_RENDERABLE = $8287;
  GL_STENCIL_RENDERABLE = $8288;
  GL_FRAMEBUFFER_RENDERABLE = $8289;
  GL_FRAMEBUFFER_RENDERABLE_LAYERED = $828A;
  GL_FRAMEBUFFER_BLEND = $828B;
  GL_READ_PIXELS = $828C;
  GL_READ_PIXELS_FORMAT = $828D;
  GL_READ_PIXELS_TYPE = $828E;
  GL_TEXTURE_IMAGE_FORMAT = $828F;
  GL_TEXTURE_IMAGE_TYPE = $8290;
  GL_GET_TEXTURE_IMAGE_FORMAT = $8291;
  GL_GET_TEXTURE_IMAGE_TYPE = $8292;
  GL_MIPMAP = $8293;
  GL_MANUAL_GENERATE_MIPMAP = $8294;
  GL_AUTO_GENERATE_MIPMAP = $8295;
  GL_COLOR_ENCODING = $8296;
  GL_SRGB_READ = $8297;
  GL_SRGB_WRITE = $8298;
  GL_FILTER = $829A;
  GL_VERTEX_TEXTURE = $829B;
  GL_TESS_CONTROL_TEXTURE = $829C;
  GL_TESS_EVALUATION_TEXTURE = $829D;
  GL_GEOMETRY_TEXTURE = $829E;
  GL_FRAGMENT_TEXTURE = $829F;
  GL_COMPUTE_TEXTURE = $82A0;
  GL_TEXTURE_SHADOW = $82A1;
  GL_TEXTURE_GATHER = $82A2;
  GL_TEXTURE_GATHER_SHADOW = $82A3;
  GL_SHADER_IMAGE_LOAD = $82A4;
  GL_SHADER_IMAGE_STORE = $82A5;
  GL_SHADER_IMAGE_ATOMIC = $82A6;
  GL_IMAGE_TEXEL_SIZE = $82A7;
  GL_IMAGE_COMPATIBILITY_CLASS = $82A8;
  GL_IMAGE_PIXEL_FORMAT = $82A9;
  GL_IMAGE_PIXEL_TYPE = $82AA;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = $82AC;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = $82AD;
  GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = $82AE;
  GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = $82AF;
  GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = $82B1;
  GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = $82B2;
  GL_TEXTURE_COMPRESSED_BLOCK_SIZE = $82B3;
  GL_CLEAR_BUFFER = $82B4;
  GL_TEXTURE_VIEW = $82B5;
  GL_VIEW_COMPATIBILITY_CLASS = $82B6;
  GL_FULL_SUPPORT = $82B7;
  GL_CAVEAT_SUPPORT = $82B8;
  GL_IMAGE_CLASS_4_X_32 = $82B9;
  GL_IMAGE_CLASS_2_X_32 = $82BA;
  GL_IMAGE_CLASS_1_X_32 = $82BB;
  GL_IMAGE_CLASS_4_X_16 = $82BC;
  GL_IMAGE_CLASS_2_X_16 = $82BD;
  GL_IMAGE_CLASS_1_X_16 = $82BE;
  GL_IMAGE_CLASS_4_X_8 = $82BF;
  GL_IMAGE_CLASS_2_X_8 = $82C0;
  GL_IMAGE_CLASS_1_X_8 = $82C1;
  GL_IMAGE_CLASS_11_11_10 = $82C2;
  GL_IMAGE_CLASS_10_10_10_2 = $82C3;
  GL_VIEW_CLASS_128_BITS = $82C4;
  GL_VIEW_CLASS_96_BITS = $82C5;
  GL_VIEW_CLASS_64_BITS = $82C6;
  GL_VIEW_CLASS_48_BITS = $82C7;
  GL_VIEW_CLASS_32_BITS = $82C8;
  GL_VIEW_CLASS_24_BITS = $82C9;
  GL_VIEW_CLASS_16_BITS = $82CA;
  GL_VIEW_CLASS_8_BITS = $82CB;
  GL_VIEW_CLASS_S3TC_DXT1_RGB = $82CC;
  GL_VIEW_CLASS_S3TC_DXT1_RGBA = $82CD;
  GL_VIEW_CLASS_S3TC_DXT3_RGBA = $82CE;
  GL_VIEW_CLASS_S3TC_DXT5_RGBA = $82CF;
  GL_VIEW_CLASS_RGTC1_RED = $82D0;
  GL_VIEW_CLASS_RGTC2_RG = $82D1;
  GL_VIEW_CLASS_BPTC_UNORM = $82D2;
  GL_VIEW_CLASS_BPTC_FLOAT = $82D3;
  GL_UNIFORM = $92E1;
  GL_UNIFORM_BLOCK = $92E2;
  GL_PROGRAM_INPUT = $92E3;
  GL_PROGRAM_OUTPUT = $92E4;
  GL_BUFFER_VARIABLE = $92E5;
  GL_SHADER_STORAGE_BLOCK = $92E6;
  GL_VERTEX_SUBROUTINE = $92E8;
  GL_TESS_CONTROL_SUBROUTINE = $92E9;
  GL_TESS_EVALUATION_SUBROUTINE = $92EA;
  GL_GEOMETRY_SUBROUTINE = $92EB;
  GL_FRAGMENT_SUBROUTINE = $92EC;
  GL_COMPUTE_SUBROUTINE = $92ED;
  GL_VERTEX_SUBROUTINE_UNIFORM = $92EE;
  GL_TESS_CONTROL_SUBROUTINE_UNIFORM = $92EF;
  GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = $92F0;
  GL_GEOMETRY_SUBROUTINE_UNIFORM = $92F1;
  GL_FRAGMENT_SUBROUTINE_UNIFORM = $92F2;
  GL_COMPUTE_SUBROUTINE_UNIFORM = $92F3;
  GL_TRANSFORM_FEEDBACK_VARYING = $92F4;
  GL_ACTIVE_RESOURCES = $92F5;
  GL_MAX_NAME_LENGTH = $92F6;
  GL_MAX_NUM_ACTIVE_VARIABLES = $92F7;
  GL_MAX_NUM_COMPATIBLE_SUBROUTINES = $92F8;
  GL_NAME_LENGTH = $92F9;
  GL_TYPE = $92FA;
  GL_ARRAY_SIZE = $92FB;
  GL_OFFSET = $92FC;
  GL_BLOCK_INDEX = $92FD;
  GL_ARRAY_STRIDE = $92FE;
  GL_MATRIX_STRIDE = $92FF;
  GL_IS_ROW_MAJOR = $9300;
  GL_ATOMIC_COUNTER_BUFFER_INDEX = $9301;
  GL_BUFFER_BINDING = $9302;
  GL_BUFFER_DATA_SIZE = $9303;
  GL_NUM_ACTIVE_VARIABLES = $9304;
  GL_ACTIVE_VARIABLES = $9305;
  GL_REFERENCED_BY_VERTEX_SHADER = $9306;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER = $9307;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER = $9308;
  GL_REFERENCED_BY_GEOMETRY_SHADER = $9309;
  GL_REFERENCED_BY_FRAGMENT_SHADER = $930A;
  GL_REFERENCED_BY_COMPUTE_SHADER = $930B;
  GL_TOP_LEVEL_ARRAY_SIZE = $930C;
  GL_TOP_LEVEL_ARRAY_STRIDE = $930D;
  GL_LOCATION = $930E;
  GL_LOCATION_INDEX = $930F;
  GL_IS_PER_PATCH = $92E7;
  GL_SHADER_STORAGE_BUFFER = $90D2;
  GL_SHADER_STORAGE_BUFFER_BINDING = $90D3;
  GL_SHADER_STORAGE_BUFFER_START = $90D4;
  GL_SHADER_STORAGE_BUFFER_SIZE = $90D5;
  GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = $90D6;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = $90D7;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = $90D8;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = $90D9;
  GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = $90DA;
  GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = $90DB;
  GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = $90DC;
  GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = $90DD;
  GL_MAX_SHADER_STORAGE_BLOCK_SIZE = $90DE;
  GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = $90DF;
  GL_SHADER_STORAGE_BARRIER_BIT = $00002000;
  GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = $8F39;
  GL_DEPTH_STENCIL_TEXTURE_MODE = $90EA;
  GL_TEXTURE_BUFFER_OFFSET = $919D;
  GL_TEXTURE_BUFFER_SIZE = $919E;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = $919F;
  GL_TEXTURE_VIEW_MIN_LEVEL = $82DB;
  GL_TEXTURE_VIEW_NUM_LEVELS = $82DC;
  GL_TEXTURE_VIEW_MIN_LAYER = $82DD;
  GL_TEXTURE_VIEW_NUM_LAYERS = $82DE;
  GL_TEXTURE_IMMUTABLE_LEVELS = $82DF;
  GL_VERTEX_ATTRIB_BINDING = $82D4;
  GL_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D5;
  GL_VERTEX_BINDING_DIVISOR = $82D6;
  GL_VERTEX_BINDING_OFFSET = $82D7;
  GL_VERTEX_BINDING_STRIDE = $82D8;
  GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = $82D9;
  GL_MAX_VERTEX_ATTRIB_BINDINGS = $82DA;
  GL_VERTEX_BINDING_BUFFER = $8F4F;
  GL_DISPLAY_LIST = $82E7;
  GL_STACK_UNDERFLOW = $0504;
  GL_STACK_OVERFLOW = $0503;
  GL_MAX_VERTEX_ATTRIB_STRIDE = $82E5;
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = $8221;
  GL_TEXTURE_BUFFER_BINDING = $8C2A;
  GL_MAP_PERSISTENT_BIT = $0040;
  GL_MAP_COHERENT_BIT = $0080;
  GL_DYNAMIC_STORAGE_BIT = $0100;
  GL_CLIENT_STORAGE_BIT = $0200;
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = $00004000;
  GL_BUFFER_IMMUTABLE_STORAGE = $821F;
  GL_BUFFER_STORAGE_FLAGS = $8220;
  GL_CLEAR_TEXTURE = $9365;
  GL_LOCATION_COMPONENT = $934A;
  GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = $934B;
  GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = $934C;
  GL_QUERY_BUFFER = $9192;
  GL_QUERY_BUFFER_BARRIER_BIT = $00008000;
  GL_QUERY_BUFFER_BINDING = $9193;
  GL_QUERY_RESULT_NO_WAIT = $9194;
  GL_MIRROR_CLAMP_TO_EDGE = $8743;
  GL_CONTEXT_LOST = $0507;
  GL_NEGATIVE_ONE_TO_ONE = $935E;
  GL_ZERO_TO_ONE = $935F;
  GL_CLIP_ORIGIN = $935C;
  GL_CLIP_DEPTH_MODE = $935D;
  GL_QUERY_WAIT_INVERTED = $8E17;
  GL_QUERY_NO_WAIT_INVERTED = $8E18;
  GL_QUERY_BY_REGION_WAIT_INVERTED = $8E19;
  GL_QUERY_BY_REGION_NO_WAIT_INVERTED = $8E1A;
  GL_MAX_CULL_DISTANCES = $82F9;
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = $82FA;
  GL_TEXTURE_TARGET = $1006;
  GL_QUERY_TARGET = $82EA;
  GL_GUILTY_CONTEXT_RESET = $8253;
  GL_INNOCENT_CONTEXT_RESET = $8254;
  GL_UNKNOWN_CONTEXT_RESET = $8255;
  GL_RESET_NOTIFICATION_STRATEGY = $8256;
  GL_LOSE_CONTEXT_ON_RESET = $8252;
  GL_NO_RESET_NOTIFICATION = $8261;
  GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT = $00000004;
  GL_COLOR_TABLE = $80D0;
  GL_POST_CONVOLUTION_COLOR_TABLE = $80D1;
  GL_POST_COLOR_MATRIX_COLOR_TABLE = $80D2;
  GL_PROXY_COLOR_TABLE = $80D3;
  GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = $80D4;
  GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = $80D5;
  GL_CONVOLUTION_1D = $8010;
  GL_CONVOLUTION_2D = $8011;
  GL_SEPARABLE_2D = $8012;
  GL_HISTOGRAM = $8024;
  GL_PROXY_HISTOGRAM = $8025;
  GL_MINMAX = $802E;
  GL_CONTEXT_RELEASE_BEHAVIOR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = $82FC;
  GL_SHADER_BINARY_FORMAT_SPIR_V = $9551;
  GL_SPIR_V_BINARY = $9552;
  GL_PARAMETER_BUFFER = $80EE;
  GL_PARAMETER_BUFFER_BINDING = $80EF;
  GL_CONTEXT_FLAG_NO_ERROR_BIT = $00000008;
  GL_VERTICES_SUBMITTED = $82EE;
  GL_PRIMITIVES_SUBMITTED = $82EF;
  GL_VERTEX_SHADER_INVOCATIONS = $82F0;
  GL_TESS_CONTROL_SHADER_PATCHES = $82F1;
  GL_TESS_EVALUATION_SHADER_INVOCATIONS = $82F2;
  GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED = $82F3;
  GL_FRAGMENT_SHADER_INVOCATIONS = $82F4;
  GL_COMPUTE_SHADER_INVOCATIONS = $82F5;
  GL_CLIPPING_INPUT_PRIMITIVES = $82F6;
  GL_CLIPPING_OUTPUT_PRIMITIVES = $82F7;
  GL_POLYGON_OFFSET_CLAMP = $8E1B;
  GL_SPIR_V_EXTENSIONS = $9553;
  GL_NUM_SPIR_V_EXTENSIONS = $9554;
  GL_TEXTURE_MAX_ANISOTROPY = $84FE;
  GL_MAX_TEXTURE_MAX_ANISOTROPY = $84FF;
  GL_TRANSFORM_FEEDBACK_OVERFLOW = $82EC;
  GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW = $82ED;

  (* Functions *)
var
  GLAD_GL_VERSION_1_0: boolean;
  GLAD_GL_VERSION_1_1: boolean;
  GLAD_GL_VERSION_1_2: boolean;
  GLAD_GL_VERSION_1_3: boolean;
  GLAD_GL_VERSION_1_4: boolean;
  GLAD_GL_VERSION_1_5: boolean;
  GLAD_GL_VERSION_2_0: boolean;
  GLAD_GL_VERSION_2_1: boolean;
  GLAD_GL_VERSION_3_0: boolean;
  GLAD_GL_VERSION_3_1: boolean;
  GLAD_GL_VERSION_3_2: boolean;
  GLAD_GL_VERSION_3_3: boolean;
  GLAD_GL_VERSION_4_0: boolean;
  GLAD_GL_VERSION_4_1: boolean;
  GLAD_GL_VERSION_4_2: boolean;
  GLAD_GL_VERSION_4_3: boolean;
  GLAD_GL_VERSION_4_4: boolean;
  GLAD_GL_VERSION_4_5: boolean;
  GLAD_GL_VERSION_4_6: boolean;

var
  glCullFace: procedure(mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFrontFace: procedure(mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glHint: procedure(target: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glLineWidth: procedure(Width: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPointSize: procedure(size: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPolygonMode: procedure(face: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glScissor: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexParameterf: procedure(target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexParameterfv: procedure(target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexParameteri: procedure(target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexImage1D: procedure(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexImage2D: procedure(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawBuffer: procedure(buf: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClear: procedure(mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearColor: procedure(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearStencil: procedure(s: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearDepth: procedure(depth: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glStencilMask: procedure(mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glColorMask: procedure(red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDepthMask: procedure(flag: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDisable: procedure(cap: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEnable: procedure(cap: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFinish: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFlush: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendFunc: procedure(sfactor: GLenum; dfactor: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glLogicOp: procedure(opcode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glStencilFunc: procedure(func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glStencilOp: procedure(fail: GLenum; zfail: GLenum; zpass: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDepthFunc: procedure(func: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPixelStoref: procedure(pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPixelStorei: procedure(pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glReadBuffer: procedure(src: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glReadPixels: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetBooleanv: procedure(pname: GLenum; Data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetDoublev: procedure(pname: GLenum; Data: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetError: function(): GLenum; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetFloatv: procedure(pname: GLenum; Data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetIntegerv: procedure(pname: GLenum; Data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetString: function(Name: GLenum): PGLubyte; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTexImage: procedure(target: GLenum; level: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTexParameterfv: procedure(target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTexParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTexLevelParameterfv: procedure(target: GLenum; level: GLint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTexLevelParameteriv: procedure(target: GLenum; level: GLint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsEnabled: function(cap: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDepthRange: procedure(n: GLdouble; f: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glViewport: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawArrays: procedure(mode: GLenum; First: GLint; Count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawElements: procedure(mode: GLenum; Count: GLsizei; type_: GLenum; indices: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPolygonOffset: procedure(factor: GLfloat; units: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTexImage1D: procedure(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTexImage2D: procedure(target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTexSubImage1D: procedure(target: GLenum; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTexSubImage2D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexSubImage1D: procedure(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexSubImage2D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindTexture: procedure(target: GLenum; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteTextures: procedure(n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenTextures: procedure(n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsTexture: function(texture: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawRangeElements: procedure(mode: GLenum; start: GLuint; end_: GLuint; Count: GLsizei; type_: GLenum; indices: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexImage3D: procedure(target: GLenum; level: GLint; internalformat: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexSubImage3D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTexSubImage3D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glActiveTexture: procedure(texture: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSampleCoverage: procedure(Value: GLfloat; invert: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTexImage3D: procedure(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTexImage2D: procedure(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; Height: GLsizei; border: GLint; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTexImage1D: procedure(target: GLenum; level: GLint; internalformat: GLenum; Width: GLsizei; border: GLint; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTexSubImage3D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTexSubImage2D: procedure(target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTexSubImage1D: procedure(target: GLenum; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetCompressedTexImage: procedure(target: GLenum; level: GLint; img: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendFuncSeparate: procedure(sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiDrawArrays: procedure(mode: GLenum; First: PGLint; Count: PGLsizei; drawcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiDrawElements: procedure(mode: GLenum; Count: PGLsizei; type_: GLenum; indices: PPointer; drawcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPointParameterf: procedure(pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPointParameterfv: procedure(pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPointParameteri: procedure(pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPointParameteriv: procedure(pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendColor: procedure(red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendEquation: procedure(mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenQueries: procedure(n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteQueries: procedure(n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsQuery: function(id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBeginQuery: procedure(target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEndQuery: procedure(target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryiv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryObjectiv: procedure(id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryObjectuiv: procedure(id: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindBuffer: procedure(target: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteBuffers: procedure(n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenBuffers: procedure(n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsBuffer: function(buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBufferData: procedure(target: GLenum; size: GLsizeiptr; Data: Pointer; usage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBufferSubData: procedure(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetBufferSubData: procedure(target: GLenum; offset: GLintptr; size: GLsizeiptr; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMapBuffer: function(target: GLenum; access: GLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUnmapBuffer: function(target: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetBufferParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetBufferPointerv: procedure(target: GLenum; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendEquationSeparate: procedure(modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawBuffers: procedure(n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glStencilOpSeparate: procedure(face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glStencilFuncSeparate: procedure(face: GLenum; func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glStencilMaskSeparate: procedure(face: GLenum; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glAttachShader: procedure(program_: GLuint; shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindAttribLocation: procedure(program_: GLuint; index: GLuint; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompileShader: procedure(shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateProgram: function(): GLuint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateShader: function(type_: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteProgram: procedure(program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteShader: procedure(shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDetachShader: procedure(program_: GLuint; shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDisableVertexAttribArray: procedure(index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEnableVertexAttribArray: procedure(index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveAttrib: procedure(program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveUniform: procedure(program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetAttachedShaders: procedure(program_: GLuint; maxCount: GLsizei; Count: PGLsizei; shaders: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetAttribLocation: function(program_: GLuint; Name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramiv: procedure(program_: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramInfoLog: procedure(program_: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetShaderiv: procedure(shader: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetShaderInfoLog: procedure(shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetShaderSource: procedure(shader: GLuint; bufSize: GLsizei; length: PGLsizei; Source: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformLocation: function(program_: GLuint; Name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformfv: procedure(program_: GLuint; location: GLint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformiv: procedure(program_: GLuint; location: GLint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexAttribdv: procedure(index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexAttribfv: procedure(index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexAttribiv: procedure(index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexAttribPointerv: procedure(index: GLuint; pname: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsProgram: function(program_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsShader: function(shader: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glLinkProgram: procedure(program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glShaderSource: procedure(shader: GLuint; Count: GLsizei; string_: PPGLchar; length: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUseProgram: procedure(program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1f: procedure(location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2f: procedure(location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3f: procedure(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4f: procedure(location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1i: procedure(location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2i: procedure(location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3i: procedure(location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4i: procedure(location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1fv: procedure(location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2fv: procedure(location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3fv: procedure(location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4fv: procedure(location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1iv: procedure(location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2iv: procedure(location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3iv: procedure(location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4iv: procedure(location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix2fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix3fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix4fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glValidateProgram: procedure(program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib1d: procedure(index: GLuint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib1dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib1f: procedure(index: GLuint; x: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib1fv: procedure(index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib1s: procedure(index: GLuint; x: GLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib1sv: procedure(index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib2d: procedure(index: GLuint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib2dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib2f: procedure(index: GLuint; x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib2fv: procedure(index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib2s: procedure(index: GLuint; x: GLshort; y: GLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib2sv: procedure(index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib3d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib3dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib3f: procedure(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib3fv: procedure(index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib3s: procedure(index: GLuint; x: GLshort; y: GLshort; z: GLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib3sv: procedure(index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4Nbv: procedure(index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4Niv: procedure(index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4Nsv: procedure(index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4Nub: procedure(index: GLuint; x: GLubyte; y: GLubyte; z: GLubyte; w: GLubyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4Nubv: procedure(index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4Nuiv: procedure(index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4Nusv: procedure(index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4bv: procedure(index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4f: procedure(index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4fv: procedure(index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4iv: procedure(index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4s: procedure(index: GLuint; x: GLshort; y: GLshort; z: GLshort; w: GLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4sv: procedure(index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4ubv: procedure(index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4uiv: procedure(index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttrib4usv: procedure(index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribPointer: procedure(index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix2x3fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix3x2fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix2x4fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix4x2fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix3x4fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix4x3fv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glColorMaski: procedure(index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetBooleani_v: procedure(target: GLenum; index: GLuint; Data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetIntegeri_v: procedure(target: GLenum; index: GLuint; Data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEnablei: procedure(target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDisablei: procedure(target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsEnabledi: function(target: GLenum; index: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBeginTransformFeedback: procedure(primitiveMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEndTransformFeedback: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindBufferRange: procedure(target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindBufferBase: procedure(target: GLenum; index: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTransformFeedbackVaryings: procedure(program_: GLuint; Count: GLsizei; varyings: PPGLchar; bufferMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTransformFeedbackVarying: procedure(program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; type_: PGLenum; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClampColor: procedure(target: GLenum; clamp: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBeginConditionalRender: procedure(id: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEndConditionalRender: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribIPointer: procedure(index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexAttribIiv: procedure(index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexAttribIuiv: procedure(index: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI1i: procedure(index: GLuint; x: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI2i: procedure(index: GLuint; x: GLint; y: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI3i: procedure(index: GLuint; x: GLint; y: GLint; z: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4i: procedure(index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI1ui: procedure(index: GLuint; x: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI2ui: procedure(index: GLuint; x: GLuint; y: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI3ui: procedure(index: GLuint; x: GLuint; y: GLuint; z: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4ui: procedure(index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI1iv: procedure(index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI2iv: procedure(index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI3iv: procedure(index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4iv: procedure(index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI1uiv: procedure(index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI2uiv: procedure(index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI3uiv: procedure(index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4uiv: procedure(index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4bv: procedure(index: GLuint; v: PGLbyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4sv: procedure(index: GLuint; v: PGLshort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4ubv: procedure(index: GLuint; v: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribI4usv: procedure(index: GLuint; v: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformuiv: procedure(program_: GLuint; location: GLint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindFragDataLocation: procedure(program_: GLuint; color: GLuint; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetFragDataLocation: function(program_: GLuint; Name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1ui: procedure(location: GLint; v0: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2ui: procedure(location: GLint; v0: GLuint; v1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3ui: procedure(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4ui: procedure(location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1uiv: procedure(location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2uiv: procedure(location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3uiv: procedure(location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4uiv: procedure(location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexParameterIiv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexParameterIuiv: procedure(target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTexParameterIiv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTexParameterIuiv: procedure(target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearBufferiv: procedure(buffer: GLenum; drawbuffer: GLint; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearBufferuiv: procedure(buffer: GLenum; drawbuffer: GLint; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearBufferfv: procedure(buffer: GLenum; drawbuffer: GLint; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearBufferfi: procedure(buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetStringi: function(Name: GLenum; index: GLuint): PGLubyte; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsRenderbuffer: function(renderbuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindRenderbuffer: procedure(target: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteRenderbuffers: procedure(n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenRenderbuffers: procedure(n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glRenderbufferStorage: procedure(target: GLenum; internalformat: GLenum; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetRenderbufferParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsFramebuffer: function(framebuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindFramebuffer: procedure(target: GLenum; framebuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteFramebuffers: procedure(n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenFramebuffers: procedure(n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCheckFramebufferStatus: function(target: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFramebufferTexture1D: procedure(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFramebufferTexture2D: procedure(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFramebufferTexture3D: procedure(target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFramebufferRenderbuffer: procedure(target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetFramebufferAttachmentParameteriv: procedure(target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenerateMipmap: procedure(target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlitFramebuffer: procedure(srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glRenderbufferStorageMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFramebufferTextureLayer: procedure(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMapBufferRange: function(target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFlushMappedBufferRange: procedure(target: GLenum; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindVertexArray: procedure(array_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteVertexArrays: procedure(n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenVertexArrays: procedure(n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsVertexArray: function(array_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawArraysInstanced: procedure(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawElementsInstanced: procedure(mode: GLenum; Count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexBuffer: procedure(target: GLenum; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPrimitiveRestartIndex: procedure(index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyBufferSubData: procedure(readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformIndices: procedure(program_: GLuint; uniformCount: GLsizei; uniformNames: PPGLchar; uniformIndices: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveUniformsiv: procedure(program_: GLuint; uniformCount: GLsizei; uniformIndices: PGLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveUniformName: procedure(program_: GLuint; uniformIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformName: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformBlockIndex: function(program_: GLuint; uniformBlockName: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveUniformBlockiv: procedure(program_: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveUniformBlockName: procedure(program_: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformBlockBinding: procedure(program_: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawElementsBaseVertex: procedure(mode: GLenum; Count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawRangeElementsBaseVertex: procedure(mode: GLenum; start: GLuint; end_: GLuint; Count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawElementsInstancedBaseVertex: procedure(mode: GLenum; Count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiDrawElementsBaseVertex: procedure(mode: GLenum; Count: PGLsizei; type_: GLenum; indices: PPointer; drawcount: GLsizei; basevertex: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProvokingVertex: procedure(mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFenceSync: function(condition: GLenum; flags: GLbitfield): GLsync; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsSync: function(sync: GLsync): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteSync: procedure(sync: GLsync); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClientWaitSync: function(sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glWaitSync: procedure(sync: GLsync; flags: GLbitfield; timeout: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetInteger64v: procedure(pname: GLenum; Data: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetSynciv: procedure(sync: GLsync; pname: GLenum; Count: GLsizei; length: PGLsizei; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetInteger64i_v: procedure(target: GLenum; index: GLuint; Data: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetBufferParameteri64v: procedure(target: GLenum; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFramebufferTexture: procedure(target: GLenum; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexImage2DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexImage3DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetMultisamplefv: procedure(pname: GLenum; index: GLuint; val: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSampleMaski: procedure(maskNumber: GLuint; mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindFragDataLocationIndexed: procedure(program_: GLuint; colorNumber: GLuint; index: GLuint; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetFragDataIndex: function(program_: GLuint; Name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenSamplers: procedure(Count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteSamplers: procedure(Count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsSampler: function(sampler: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindSampler: procedure(unit_: GLuint; sampler: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSamplerParameteri: procedure(sampler: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSamplerParameteriv: procedure(sampler: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSamplerParameterf: procedure(sampler: GLuint; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSamplerParameterfv: procedure(sampler: GLuint; pname: GLenum; param: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSamplerParameterIiv: procedure(sampler: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSamplerParameterIuiv: procedure(sampler: GLuint; pname: GLenum; param: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetSamplerParameteriv: procedure(sampler: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetSamplerParameterIiv: procedure(sampler: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetSamplerParameterfv: procedure(sampler: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetSamplerParameterIuiv: procedure(sampler: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glQueryCounter: procedure(id: GLuint; target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryObjecti64v: procedure(id: GLuint; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryObjectui64v: procedure(id: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribDivisor: procedure(index: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP1ui: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP1uiv: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP2ui: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP2uiv: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP3ui: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP3uiv: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP4ui: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribP4uiv: procedure(index: GLuint; type_: GLenum; normalized: GLboolean; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexP2ui: procedure(type_: GLenum; Value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexP2uiv: procedure(type_: GLenum; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexP3ui: procedure(type_: GLenum; Value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexP3uiv: procedure(type_: GLenum; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexP4ui: procedure(type_: GLenum; Value: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexP4uiv: procedure(type_: GLenum; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP1ui: procedure(type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP1uiv: procedure(type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP2ui: procedure(type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP2uiv: procedure(type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP3ui: procedure(type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP3uiv: procedure(type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP4ui: procedure(type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexCoordP4uiv: procedure(type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP1ui: procedure(texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP1uiv: procedure(texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP2ui: procedure(texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP2uiv: procedure(texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP3ui: procedure(texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP3uiv: procedure(texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP4ui: procedure(texture: GLenum; type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiTexCoordP4uiv: procedure(texture: GLenum; type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNormalP3ui: procedure(type_: GLenum; coords: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNormalP3uiv: procedure(type_: GLenum; coords: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glColorP3ui: procedure(type_: GLenum; color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glColorP3uiv: procedure(type_: GLenum; color: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glColorP4ui: procedure(type_: GLenum; color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glColorP4uiv: procedure(type_: GLenum; color: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSecondaryColorP3ui: procedure(type_: GLenum; color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSecondaryColorP3uiv: procedure(type_: GLenum; color: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMinSampleShading: procedure(Value: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendEquationi: procedure(buf: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendEquationSeparatei: procedure(buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendFunci: procedure(buf: GLuint; src: GLenum; dst: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlendFuncSeparatei: procedure(buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawArraysIndirect: procedure(mode: GLenum; indirect: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawElementsIndirect: procedure(mode: GLenum; type_: GLenum; indirect: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1d: procedure(location: GLint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2d: procedure(location: GLint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3d: procedure(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4d: procedure(location: GLint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform1dv: procedure(location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform2dv: procedure(location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform3dv: procedure(location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniform4dv: procedure(location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix2dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix3dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix4dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix2x3dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix2x4dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix3x2dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix3x4dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix4x2dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformMatrix4x3dv: procedure(location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformdv: procedure(program_: GLuint; location: GLint; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetSubroutineUniformLocation: function(program_: GLuint; shadertype: GLenum; Name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetSubroutineIndex: function(program_: GLuint; shadertype: GLenum; Name: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveSubroutineUniformiv: procedure(program_: GLuint; shadertype: GLenum; index: GLuint; pname: GLenum; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveSubroutineUniformName: procedure(program_: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveSubroutineName: procedure(program_: GLuint; shadertype: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUniformSubroutinesuiv: procedure(shadertype: GLenum; Count: GLsizei; indices: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetUniformSubroutineuiv: procedure(shadertype: GLenum; location: GLint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramStageiv: procedure(program_: GLuint; shadertype: GLenum; pname: GLenum; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPatchParameteri: procedure(pname: GLenum; Value: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPatchParameterfv: procedure(pname: GLenum; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindTransformFeedback: procedure(target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteTransformFeedbacks: procedure(n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenTransformFeedbacks: procedure(n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsTransformFeedback: function(id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPauseTransformFeedback: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glResumeTransformFeedback: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawTransformFeedback: procedure(mode: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawTransformFeedbackStream: procedure(mode: GLenum; id: GLuint; stream: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBeginQueryIndexed: procedure(target: GLenum; index: GLuint; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEndQueryIndexed: procedure(target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryIndexediv: procedure(target: GLenum; index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glReleaseShaderCompiler: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glShaderBinary: procedure(Count: GLsizei; shaders: PGLuint; binaryFormat: GLenum; binary: Pointer; length: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetShaderPrecisionFormat: procedure(shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDepthRangef: procedure(n: GLfloat; f: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearDepthf: procedure(d: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramBinary: procedure(program_: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramBinary: procedure(program_: GLuint; binaryFormat: GLenum; binary: Pointer; length: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramParameteri: procedure(program_: GLuint; pname: GLenum; Value: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUseProgramStages: procedure(pipeline: GLuint; stages: GLbitfield; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glActiveShaderProgram: procedure(pipeline: GLuint; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateShaderProgramv: function(type_: GLenum; Count: GLsizei; strings: PPGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindProgramPipeline: procedure(pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDeleteProgramPipelines: procedure(n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenProgramPipelines: procedure(n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glIsProgramPipeline: function(pipeline: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramPipelineiv: procedure(pipeline: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1i: procedure(program_: GLuint; location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1iv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1f: procedure(program_: GLuint; location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1d: procedure(program_: GLuint; location: GLint; v0: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1ui: procedure(program_: GLuint; location: GLint; v0: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform1uiv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2i: procedure(program_: GLuint; location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2iv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2f: procedure(program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2d: procedure(program_: GLuint; location: GLint; v0: GLdouble; v1: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2ui: procedure(program_: GLuint; location: GLint; v0: GLuint; v1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform2uiv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3i: procedure(program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3iv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3f: procedure(program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3d: procedure(program_: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3ui: procedure(program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform3uiv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4i: procedure(program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4iv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4f: procedure(program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4d: procedure(program_: GLuint; location: GLint; v0: GLdouble; v1: GLdouble; v2: GLdouble; v3: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4ui: procedure(program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniform4uiv: procedure(program_: GLuint; location: GLint; Count: GLsizei; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix2fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix3fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix4fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix2dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix3dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix4dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix2x3fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix3x2fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix2x4fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix4x2fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix3x4fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix4x3fv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix2x3dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix3x2dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix2x4dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix4x2dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix3x4dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glProgramUniformMatrix4x3dv: procedure(program_: GLuint; location: GLint; Count: GLsizei; transpose: GLboolean; Value: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glValidateProgramPipeline: procedure(pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramPipelineInfoLog: procedure(pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL1d: procedure(index: GLuint; x: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL2d: procedure(index: GLuint; x: GLdouble; y: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL3d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL4d: procedure(index: GLuint; x: GLdouble; y: GLdouble; z: GLdouble; w: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL1dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL2dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL3dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribL4dv: procedure(index: GLuint; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribLPointer: procedure(index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexAttribLdv: procedure(index: GLuint; pname: GLenum; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glViewportArrayv: procedure(First: GLuint; Count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glViewportIndexedf: procedure(index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glViewportIndexedfv: procedure(index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glScissorArrayv: procedure(First: GLuint; Count: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glScissorIndexed: procedure(index: GLuint; left: GLint; bottom: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glScissorIndexedv: procedure(index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDepthRangeArrayv: procedure(First: GLuint; Count: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDepthRangeIndexed: procedure(index: GLuint; n: GLdouble; f: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetFloati_v: procedure(target: GLenum; index: GLuint; Data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetDoublei_v: procedure(target: GLenum; index: GLuint; Data: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawArraysInstancedBaseInstance: procedure(mode: GLenum; First: GLint; Count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawElementsInstancedBaseInstance: procedure(mode: GLenum; Count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawElementsInstancedBaseVertexBaseInstance: procedure(mode: GLenum; Count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetInternalformativ: procedure(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetActiveAtomicCounterBufferiv: procedure(program_: GLuint; bufferIndex: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindImageTexture: procedure(unit_: GLuint; texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; access: GLenum; format: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMemoryBarrier: procedure(barriers: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexStorage1D: procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexStorage2D: procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexStorage3D: procedure(target: GLenum; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawTransformFeedbackInstanced: procedure(mode: GLenum; id: GLuint; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDrawTransformFeedbackStreamInstanced: procedure(mode: GLenum; id: GLuint; stream: GLuint; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearBufferData: procedure(target: GLenum; internalformat: GLenum; format: GLenum; type_: GLenum; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearBufferSubData: procedure(target: GLenum; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; type_: GLenum; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDispatchCompute: procedure(num_groups_x: GLuint; num_groups_y: GLuint; num_groups_z: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDispatchComputeIndirect: procedure(indirect: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyImageSubData: procedure(srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei;
  srcHeight: GLsizei; srcDepth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFramebufferParameteri: procedure(target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetFramebufferParameteriv: procedure(target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetInternalformati64v: procedure(target: GLenum; internalformat: GLenum; pname: GLenum; Count: GLsizei; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateTexSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateTexImage: procedure(texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateBufferSubData: procedure(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateBufferData: procedure(buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateFramebuffer: procedure(target: GLenum; numAttachments: GLsizei; attachments: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateSubFramebuffer: procedure(target: GLenum; numAttachments: GLsizei; attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiDrawArraysIndirect: procedure(mode: GLenum; indirect: Pointer; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiDrawElementsIndirect: procedure(mode: GLenum; type_: GLenum; indirect: Pointer; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramInterfaceiv: procedure(program_: GLuint; programInterface: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramResourceIndex: function(program_: GLuint; programInterface: GLenum; Name: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramResourceName: procedure(program_: GLuint; programInterface: GLenum; index: GLuint; bufSize: GLsizei; length: PGLsizei; Name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramResourceiv: procedure(program_: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; props: PGLenum; Count: GLsizei; length: PGLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramResourceLocation: function(program_: GLuint; programInterface: GLenum; Name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetProgramResourceLocationIndex: function(program_: GLuint; programInterface: GLenum; Name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glShaderStorageBlockBinding: procedure(program_: GLuint; storageBlockIndex: GLuint; storageBlockBinding: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexBufferRange: procedure(target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexStorage2DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTexStorage3DMultisample: procedure(target: GLenum; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureView: procedure(texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindVertexBuffer: procedure(bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribFormat: procedure(attribindex: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribIFormat: procedure(attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribLFormat: procedure(attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexAttribBinding: procedure(attribindex: GLuint; bindingindex: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexBindingDivisor: procedure(bindingindex: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDebugMessageControl: procedure(Source: GLenum; type_: GLenum; severity: GLenum; Count: GLsizei; ids: PGLuint; Enabled: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDebugMessageInsert: procedure(Source: GLenum; type_: GLenum; id: GLuint; severity: GLenum; length: GLsizei; buf: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDebugMessageCallback: procedure(callback: GLDEBUGPROC; userParam: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetDebugMessageLog: function(Count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPushDebugGroup: procedure(Source: GLenum; id: GLuint; length: GLsizei; message: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPopDebugGroup: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glObjectLabel: procedure(identifier: GLenum; Name: GLuint; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetObjectLabel: procedure(identifier: GLenum; Name: GLuint; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glObjectPtrLabel: procedure(ptr: Pointer; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetObjectPtrLabel: procedure(ptr: Pointer; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetPointerv: procedure(pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBufferStorage: procedure(target: GLenum; size: GLsizeiptr; Data: Pointer; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearTexImage: procedure(texture: GLuint; level: GLint; format: GLenum; type_: GLenum; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearTexSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindBuffersBase: procedure(target: GLenum; First: GLuint; Count: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindBuffersRange: procedure(target: GLenum; First: GLuint; Count: GLsizei; buffers: PGLuint; offsets: PGLintptr; sizes: PGLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindTextures: procedure(First: GLuint; Count: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindSamplers: procedure(First: GLuint; Count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindImageTextures: procedure(First: GLuint; Count: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindVertexBuffers: procedure(First: GLuint; Count: GLsizei; buffers: PGLuint; offsets: PGLintptr; strides: PGLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClipControl: procedure(origin: GLenum; depth: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateTransformFeedbacks: procedure(n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTransformFeedbackBufferBase: procedure(xfb: GLuint; index: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTransformFeedbackBufferRange: procedure(xfb: GLuint; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTransformFeedbackiv: procedure(xfb: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTransformFeedbacki_v: procedure(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTransformFeedbacki64_v: procedure(xfb: GLuint; pname: GLenum; index: GLuint; param: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateBuffers: procedure(n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedBufferStorage: procedure(buffer: GLuint; size: GLsizeiptr; Data: Pointer; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedBufferData: procedure(buffer: GLuint; size: GLsizeiptr; Data: Pointer; usage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedBufferSubData: procedure(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyNamedBufferSubData: procedure(readBuffer: GLuint; writeBuffer: GLuint; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearNamedBufferData: procedure(buffer: GLuint; internalformat: GLenum; format: GLenum; type_: GLenum; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearNamedBufferSubData: procedure(buffer: GLuint; internalformat: GLenum; offset: GLintptr; size: GLsizeiptr; format: GLenum; type_: GLenum; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMapNamedBuffer: function(buffer: GLuint; access: GLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMapNamedBufferRange: function(buffer: GLuint; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glUnmapNamedBuffer: function(buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glFlushMappedNamedBufferRange: procedure(buffer: GLuint; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetNamedBufferParameteriv: procedure(buffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetNamedBufferParameteri64v: procedure(buffer: GLuint; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetNamedBufferPointerv: procedure(buffer: GLuint; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetNamedBufferSubData: procedure(buffer: GLuint; offset: GLintptr; size: GLsizeiptr; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateFramebuffers: procedure(n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedFramebufferRenderbuffer: procedure(framebuffer: GLuint; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedFramebufferParameteri: procedure(framebuffer: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedFramebufferTexture: procedure(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedFramebufferTextureLayer: procedure(framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedFramebufferDrawBuffer: procedure(framebuffer: GLuint; buf: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedFramebufferDrawBuffers: procedure(framebuffer: GLuint; n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedFramebufferReadBuffer: procedure(framebuffer: GLuint; src: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateNamedFramebufferData: procedure(framebuffer: GLuint; numAttachments: GLsizei; attachments: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glInvalidateNamedFramebufferSubData: procedure(framebuffer: GLuint; numAttachments: GLsizei; attachments: PGLenum; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearNamedFramebufferiv: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; Value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearNamedFramebufferuiv: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; Value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearNamedFramebufferfv: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; Value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glClearNamedFramebufferfi: procedure(framebuffer: GLuint; buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBlitNamedFramebuffer: procedure(readFramebuffer: GLuint; drawFramebuffer: GLuint; srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCheckNamedFramebufferStatus: function(framebuffer: GLuint; target: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetNamedFramebufferParameteriv: procedure(framebuffer: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetNamedFramebufferAttachmentParameteriv: procedure(framebuffer: GLuint; attachment: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateRenderbuffers: procedure(n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedRenderbufferStorage: procedure(renderbuffer: GLuint; internalformat: GLenum; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glNamedRenderbufferStorageMultisample: procedure(renderbuffer: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetNamedRenderbufferParameteriv: procedure(renderbuffer: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateTextures: procedure(target: GLenum; n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureBuffer: procedure(texture: GLuint; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureBufferRange: procedure(texture: GLuint; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureStorage1D: procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureStorage2D: procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureStorage3D: procedure(texture: GLuint; levels: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureStorage2DMultisample: procedure(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureStorage3DMultisample: procedure(texture: GLuint; samples: GLsizei; internalformat: GLenum; Width: GLsizei; Height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureSubImage1D: procedure(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureSubImage2D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureSubImage3D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTextureSubImage1D: procedure(texture: GLuint; level: GLint; xoffset: GLint; Width: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTextureSubImage2D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCompressedTextureSubImage3D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTextureSubImage1D: procedure(texture: GLuint; level: GLint; xoffset: GLint; x: GLint; y: GLint; Width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTextureSubImage2D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCopyTextureSubImage3D: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; Width: GLsizei; Height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureParameterf: procedure(texture: GLuint; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureParameterfv: procedure(texture: GLuint; pname: GLenum; param: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureParameteri: procedure(texture: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureParameterIiv: procedure(texture: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureParameterIuiv: procedure(texture: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureParameteriv: procedure(texture: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGenerateTextureMipmap: procedure(texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glBindTextureUnit: procedure(unit_: GLuint; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureImage: procedure(texture: GLuint; level: GLint; format: GLenum; type_: GLenum; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetCompressedTextureImage: procedure(texture: GLuint; level: GLint; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureLevelParameterfv: procedure(texture: GLuint; level: GLint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureLevelParameteriv: procedure(texture: GLuint; level: GLint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureParameterfv: procedure(texture: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureParameterIiv: procedure(texture: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureParameterIuiv: procedure(texture: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureParameteriv: procedure(texture: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateVertexArrays: procedure(n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glDisableVertexArrayAttrib: procedure(vaobj: GLuint; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glEnableVertexArrayAttrib: procedure(vaobj: GLuint; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayElementBuffer: procedure(vaobj: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayVertexBuffer: procedure(vaobj: GLuint; bindingindex: GLuint; buffer: GLuint; offset: GLintptr; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayVertexBuffers: procedure(vaobj: GLuint; First: GLuint; Count: GLsizei; buffers: PGLuint; offsets: PGLintptr; strides: PGLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayAttribBinding: procedure(vaobj: GLuint; attribindex: GLuint; bindingindex: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayAttribFormat: procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayAttribIFormat: procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayAttribLFormat: procedure(vaobj: GLuint; attribindex: GLuint; size: GLint; type_: GLenum; relativeoffset: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glVertexArrayBindingDivisor: procedure(vaobj: GLuint; bindingindex: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexArrayiv: procedure(vaobj: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexArrayIndexediv: procedure(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetVertexArrayIndexed64iv: procedure(vaobj: GLuint; index: GLuint; pname: GLenum; param: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateSamplers: procedure(n: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateProgramPipelines: procedure(n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glCreateQueries: procedure(target: GLenum; n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryBufferObjecti64v: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryBufferObjectiv: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryBufferObjectui64v: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetQueryBufferObjectuiv: procedure(id: GLuint; buffer: GLuint; pname: GLenum; offset: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMemoryBarrierByRegion: procedure(barriers: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetTextureSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetCompressedTextureSubImage: procedure(texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; Width: GLsizei; Height: GLsizei; depth: GLsizei; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetGraphicsResetStatus: function(): GLenum; {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnCompressedTexImage: procedure(target: GLenum; lod: GLint; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnTexImage: procedure(target: GLenum; level: GLint; format: GLenum; type_: GLenum; bufSize: GLsizei; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnUniformdv: procedure(program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnUniformfv: procedure(program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnUniformiv: procedure(program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnUniformuiv: procedure(program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glReadnPixels: procedure(x: GLint; y: GLint; Width: GLsizei; Height: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; Data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnMapdv: procedure(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnMapfv: procedure(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnMapiv: procedure(target: GLenum; query: GLenum; bufSize: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnPixelMapfv: procedure(map: GLenum; bufSize: GLsizei; values: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnPixelMapuiv: procedure(map: GLenum; bufSize: GLsizei; values: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnPixelMapusv: procedure(map: GLenum; bufSize: GLsizei; values: PGLushort); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnPolygonStipple: procedure(bufSize: GLsizei; pattern: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnColorTable: procedure(target: GLenum; format: GLenum; type_: GLenum; bufSize: GLsizei; table: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnConvolutionFilter: procedure(target: GLenum; format: GLenum; type_: GLenum; bufSize: GLsizei; image: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnSeparableFilter: procedure(target: GLenum; format: GLenum; type_: GLenum; rowBufSize: GLsizei; row: Pointer; columnBufSize: GLsizei; column: Pointer; span: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnHistogram: procedure(target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; bufSize: GLsizei; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glGetnMinmax: procedure(target: GLenum; reset: GLboolean; format: GLenum; type_: GLenum; bufSize: GLsizei; values: Pointer); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glTextureBarrier: procedure(); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glSpecializeShader: procedure(shader: GLuint; pEntryPoint: PGLchar; numSpecializationConstants: GLuint; pConstantIndex: PGLuint; pConstantValue: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiDrawArraysIndirectCount: procedure(mode: GLenum; indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glMultiDrawElementsIndirectCount: procedure(mode: GLenum; type_: GLenum; indirect: Pointer; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}
  glPolygonOffsetClamp: procedure(factor: GLfloat; units: GLfloat; clamp: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)} stdcall;{$ELSE} cdecl;{$ENDIF}


type
  TLoadProc = function(proc: pansichar): Pointer;

function gladLoadGL(load: TLoadProc): boolean;


implementation

{$DEFINE HAS_GL_NUM_EXTENSIONS}function hasExt(const extname: string): boolean;
var
  extensions: PChar;
  loc, terminator: PChar;
  {$IFDEF HAS_GL_NUM_EXTENSIONS}
  num_extensions, i: integer;
  ext: PChar;
  {$ENDIF}
begin
  Result := False;
  {$IFDEF HAS_GL_NUM_EXTENSIONS}
  if glVersionMajor >= 3 then begin
    glGetIntegerv(GL_NUM_EXTENSIONS, @num_extensions);
    for i := 0 to num_extensions - 1 do begin
      ext := PChar(glGetStringi(GL_EXTENSIONS, i));
      if strcomp(ext, PChar(extname)) = 0 then begin
        exit(True);
      end;
    end;
    exit;
  end;
  {$ENDIF}
  extensions := PChar(glGetString(GL_EXTENSIONS));
  while True do begin
    loc := strpos(extensions, PChar(extname));
    if loc = nil then begin
      exit;
    end;
    terminator := loc + length(extname);
    if (loc = extensions) or (loc[-1] = ' ') then begin
      if (terminator[0] = ' ') or (terminator[0] = #0) then begin
        exit(True);
      end;
    end;
    extensions := terminator;
  end;
end;

procedure load_GL_VERSION_1_0(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_0 then begin
    exit;
  end;
  glCullFace := load('glCullFace');
  glFrontFace := load('glFrontFace');
  glHint := load('glHint');
  glLineWidth := load('glLineWidth');
  glPointSize := load('glPointSize');
  glPolygonMode := load('glPolygonMode');
  glScissor := load('glScissor');
  glTexParameterf := load('glTexParameterf');
  glTexParameterfv := load('glTexParameterfv');
  glTexParameteri := load('glTexParameteri');
  glTexParameteriv := load('glTexParameteriv');
  glTexImage1D := load('glTexImage1D');
  glTexImage2D := load('glTexImage2D');
  glDrawBuffer := load('glDrawBuffer');
  glClear := load('glClear');
  glClearColor := load('glClearColor');
  glClearStencil := load('glClearStencil');
  glClearDepth := load('glClearDepth');
  glStencilMask := load('glStencilMask');
  glColorMask := load('glColorMask');
  glDepthMask := load('glDepthMask');
  glDisable := load('glDisable');
  glEnable := load('glEnable');
  glFinish := load('glFinish');
  glFlush := load('glFlush');
  glBlendFunc := load('glBlendFunc');
  glLogicOp := load('glLogicOp');
  glStencilFunc := load('glStencilFunc');
  glStencilOp := load('glStencilOp');
  glDepthFunc := load('glDepthFunc');
  glPixelStoref := load('glPixelStoref');
  glPixelStorei := load('glPixelStorei');
  glReadBuffer := load('glReadBuffer');
  glReadPixels := load('glReadPixels');
  glGetBooleanv := load('glGetBooleanv');
  glGetDoublev := load('glGetDoublev');
  glGetError := load('glGetError');
  glGetFloatv := load('glGetFloatv');
  glGetIntegerv := load('glGetIntegerv');
  glGetString := load('glGetString');
  glGetTexImage := load('glGetTexImage');
  glGetTexParameterfv := load('glGetTexParameterfv');
  glGetTexParameteriv := load('glGetTexParameteriv');
  glGetTexLevelParameterfv := load('glGetTexLevelParameterfv');
  glGetTexLevelParameteriv := load('glGetTexLevelParameteriv');
  glIsEnabled := load('glIsEnabled');
  glDepthRange := load('glDepthRange');
  glViewport := load('glViewport');
end;

procedure load_GL_VERSION_1_1(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_1 then begin
    exit;
  end;
  glDrawArrays := load('glDrawArrays');
  glDrawElements := load('glDrawElements');
  glPolygonOffset := load('glPolygonOffset');
  glCopyTexImage1D := load('glCopyTexImage1D');
  glCopyTexImage2D := load('glCopyTexImage2D');
  glCopyTexSubImage1D := load('glCopyTexSubImage1D');
  glCopyTexSubImage2D := load('glCopyTexSubImage2D');
  glTexSubImage1D := load('glTexSubImage1D');
  glTexSubImage2D := load('glTexSubImage2D');
  glBindTexture := load('glBindTexture');
  glDeleteTextures := load('glDeleteTextures');
  glGenTextures := load('glGenTextures');
  glIsTexture := load('glIsTexture');
end;

procedure load_GL_VERSION_1_2(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_2 then begin
    exit;
  end;
  glDrawRangeElements := load('glDrawRangeElements');
  glTexImage3D := load('glTexImage3D');
  glTexSubImage3D := load('glTexSubImage3D');
  glCopyTexSubImage3D := load('glCopyTexSubImage3D');
end;

procedure load_GL_VERSION_1_3(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_3 then begin
    exit;
  end;
  glActiveTexture := load('glActiveTexture');
  glSampleCoverage := load('glSampleCoverage');
  glCompressedTexImage3D := load('glCompressedTexImage3D');
  glCompressedTexImage2D := load('glCompressedTexImage2D');
  glCompressedTexImage1D := load('glCompressedTexImage1D');
  glCompressedTexSubImage3D := load('glCompressedTexSubImage3D');
  glCompressedTexSubImage2D := load('glCompressedTexSubImage2D');
  glCompressedTexSubImage1D := load('glCompressedTexSubImage1D');
  glGetCompressedTexImage := load('glGetCompressedTexImage');
end;

procedure load_GL_VERSION_1_4(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_4 then begin
    exit;
  end;
  glBlendFuncSeparate := load('glBlendFuncSeparate');
  glMultiDrawArrays := load('glMultiDrawArrays');
  glMultiDrawElements := load('glMultiDrawElements');
  glPointParameterf := load('glPointParameterf');
  glPointParameterfv := load('glPointParameterfv');
  glPointParameteri := load('glPointParameteri');
  glPointParameteriv := load('glPointParameteriv');
  glBlendColor := load('glBlendColor');
  glBlendEquation := load('glBlendEquation');
end;

procedure load_GL_VERSION_1_5(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_1_5 then begin
    exit;
  end;
  glGenQueries := load('glGenQueries');
  glDeleteQueries := load('glDeleteQueries');
  glIsQuery := load('glIsQuery');
  glBeginQuery := load('glBeginQuery');
  glEndQuery := load('glEndQuery');
  glGetQueryiv := load('glGetQueryiv');
  glGetQueryObjectiv := load('glGetQueryObjectiv');
  glGetQueryObjectuiv := load('glGetQueryObjectuiv');
  glBindBuffer := load('glBindBuffer');
  glDeleteBuffers := load('glDeleteBuffers');
  glGenBuffers := load('glGenBuffers');
  glIsBuffer := load('glIsBuffer');
  glBufferData := load('glBufferData');
  glBufferSubData := load('glBufferSubData');
  glGetBufferSubData := load('glGetBufferSubData');
  glMapBuffer := load('glMapBuffer');
  glUnmapBuffer := load('glUnmapBuffer');
  glGetBufferParameteriv := load('glGetBufferParameteriv');
  glGetBufferPointerv := load('glGetBufferPointerv');
end;

procedure load_GL_VERSION_2_0(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_2_0 then begin
    exit;
  end;
  glBlendEquationSeparate := load('glBlendEquationSeparate');
  glDrawBuffers := load('glDrawBuffers');
  glStencilOpSeparate := load('glStencilOpSeparate');
  glStencilFuncSeparate := load('glStencilFuncSeparate');
  glStencilMaskSeparate := load('glStencilMaskSeparate');
  glAttachShader := load('glAttachShader');
  glBindAttribLocation := load('glBindAttribLocation');
  glCompileShader := load('glCompileShader');
  glCreateProgram := load('glCreateProgram');
  glCreateShader := load('glCreateShader');
  glDeleteProgram := load('glDeleteProgram');
  glDeleteShader := load('glDeleteShader');
  glDetachShader := load('glDetachShader');
  glDisableVertexAttribArray := load('glDisableVertexAttribArray');
  glEnableVertexAttribArray := load('glEnableVertexAttribArray');
  glGetActiveAttrib := load('glGetActiveAttrib');
  glGetActiveUniform := load('glGetActiveUniform');
  glGetAttachedShaders := load('glGetAttachedShaders');
  glGetAttribLocation := load('glGetAttribLocation');
  glGetProgramiv := load('glGetProgramiv');
  glGetProgramInfoLog := load('glGetProgramInfoLog');
  glGetShaderiv := load('glGetShaderiv');
  glGetShaderInfoLog := load('glGetShaderInfoLog');
  glGetShaderSource := load('glGetShaderSource');
  glGetUniformLocation := load('glGetUniformLocation');
  glGetUniformfv := load('glGetUniformfv');
  glGetUniformiv := load('glGetUniformiv');
  glGetVertexAttribdv := load('glGetVertexAttribdv');
  glGetVertexAttribfv := load('glGetVertexAttribfv');
  glGetVertexAttribiv := load('glGetVertexAttribiv');
  glGetVertexAttribPointerv := load('glGetVertexAttribPointerv');
  glIsProgram := load('glIsProgram');
  glIsShader := load('glIsShader');
  glLinkProgram := load('glLinkProgram');
  glShaderSource := load('glShaderSource');
  glUseProgram := load('glUseProgram');
  glUniform1f := load('glUniform1f');
  glUniform2f := load('glUniform2f');
  glUniform3f := load('glUniform3f');
  glUniform4f := load('glUniform4f');
  glUniform1i := load('glUniform1i');
  glUniform2i := load('glUniform2i');
  glUniform3i := load('glUniform3i');
  glUniform4i := load('glUniform4i');
  glUniform1fv := load('glUniform1fv');
  glUniform2fv := load('glUniform2fv');
  glUniform3fv := load('glUniform3fv');
  glUniform4fv := load('glUniform4fv');
  glUniform1iv := load('glUniform1iv');
  glUniform2iv := load('glUniform2iv');
  glUniform3iv := load('glUniform3iv');
  glUniform4iv := load('glUniform4iv');
  glUniformMatrix2fv := load('glUniformMatrix2fv');
  glUniformMatrix3fv := load('glUniformMatrix3fv');
  glUniformMatrix4fv := load('glUniformMatrix4fv');
  glValidateProgram := load('glValidateProgram');
  glVertexAttrib1d := load('glVertexAttrib1d');
  glVertexAttrib1dv := load('glVertexAttrib1dv');
  glVertexAttrib1f := load('glVertexAttrib1f');
  glVertexAttrib1fv := load('glVertexAttrib1fv');
  glVertexAttrib1s := load('glVertexAttrib1s');
  glVertexAttrib1sv := load('glVertexAttrib1sv');
  glVertexAttrib2d := load('glVertexAttrib2d');
  glVertexAttrib2dv := load('glVertexAttrib2dv');
  glVertexAttrib2f := load('glVertexAttrib2f');
  glVertexAttrib2fv := load('glVertexAttrib2fv');
  glVertexAttrib2s := load('glVertexAttrib2s');
  glVertexAttrib2sv := load('glVertexAttrib2sv');
  glVertexAttrib3d := load('glVertexAttrib3d');
  glVertexAttrib3dv := load('glVertexAttrib3dv');
  glVertexAttrib3f := load('glVertexAttrib3f');
  glVertexAttrib3fv := load('glVertexAttrib3fv');
  glVertexAttrib3s := load('glVertexAttrib3s');
  glVertexAttrib3sv := load('glVertexAttrib3sv');
  glVertexAttrib4Nbv := load('glVertexAttrib4Nbv');
  glVertexAttrib4Niv := load('glVertexAttrib4Niv');
  glVertexAttrib4Nsv := load('glVertexAttrib4Nsv');
  glVertexAttrib4Nub := load('glVertexAttrib4Nub');
  glVertexAttrib4Nubv := load('glVertexAttrib4Nubv');
  glVertexAttrib4Nuiv := load('glVertexAttrib4Nuiv');
  glVertexAttrib4Nusv := load('glVertexAttrib4Nusv');
  glVertexAttrib4bv := load('glVertexAttrib4bv');
  glVertexAttrib4d := load('glVertexAttrib4d');
  glVertexAttrib4dv := load('glVertexAttrib4dv');
  glVertexAttrib4f := load('glVertexAttrib4f');
  glVertexAttrib4fv := load('glVertexAttrib4fv');
  glVertexAttrib4iv := load('glVertexAttrib4iv');
  glVertexAttrib4s := load('glVertexAttrib4s');
  glVertexAttrib4sv := load('glVertexAttrib4sv');
  glVertexAttrib4ubv := load('glVertexAttrib4ubv');
  glVertexAttrib4uiv := load('glVertexAttrib4uiv');
  glVertexAttrib4usv := load('glVertexAttrib4usv');
  glVertexAttribPointer := load('glVertexAttribPointer');
end;

procedure load_GL_VERSION_2_1(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_2_1 then begin
    exit;
  end;
  glUniformMatrix2x3fv := load('glUniformMatrix2x3fv');
  glUniformMatrix3x2fv := load('glUniformMatrix3x2fv');
  glUniformMatrix2x4fv := load('glUniformMatrix2x4fv');
  glUniformMatrix4x2fv := load('glUniformMatrix4x2fv');
  glUniformMatrix3x4fv := load('glUniformMatrix3x4fv');
  glUniformMatrix4x3fv := load('glUniformMatrix4x3fv');
end;

procedure load_GL_VERSION_3_0(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_3_0 then begin
    exit;
  end;
  glColorMaski := load('glColorMaski');
  glGetBooleani_v := load('glGetBooleani_v');
  glGetIntegeri_v := load('glGetIntegeri_v');
  glEnablei := load('glEnablei');
  glDisablei := load('glDisablei');
  glIsEnabledi := load('glIsEnabledi');
  glBeginTransformFeedback := load('glBeginTransformFeedback');
  glEndTransformFeedback := load('glEndTransformFeedback');
  glBindBufferRange := load('glBindBufferRange');
  glBindBufferBase := load('glBindBufferBase');
  glTransformFeedbackVaryings := load('glTransformFeedbackVaryings');
  glGetTransformFeedbackVarying := load('glGetTransformFeedbackVarying');
  glClampColor := load('glClampColor');
  glBeginConditionalRender := load('glBeginConditionalRender');
  glEndConditionalRender := load('glEndConditionalRender');
  glVertexAttribIPointer := load('glVertexAttribIPointer');
  glGetVertexAttribIiv := load('glGetVertexAttribIiv');
  glGetVertexAttribIuiv := load('glGetVertexAttribIuiv');
  glVertexAttribI1i := load('glVertexAttribI1i');
  glVertexAttribI2i := load('glVertexAttribI2i');
  glVertexAttribI3i := load('glVertexAttribI3i');
  glVertexAttribI4i := load('glVertexAttribI4i');
  glVertexAttribI1ui := load('glVertexAttribI1ui');
  glVertexAttribI2ui := load('glVertexAttribI2ui');
  glVertexAttribI3ui := load('glVertexAttribI3ui');
  glVertexAttribI4ui := load('glVertexAttribI4ui');
  glVertexAttribI1iv := load('glVertexAttribI1iv');
  glVertexAttribI2iv := load('glVertexAttribI2iv');
  glVertexAttribI3iv := load('glVertexAttribI3iv');
  glVertexAttribI4iv := load('glVertexAttribI4iv');
  glVertexAttribI1uiv := load('glVertexAttribI1uiv');
  glVertexAttribI2uiv := load('glVertexAttribI2uiv');
  glVertexAttribI3uiv := load('glVertexAttribI3uiv');
  glVertexAttribI4uiv := load('glVertexAttribI4uiv');
  glVertexAttribI4bv := load('glVertexAttribI4bv');
  glVertexAttribI4sv := load('glVertexAttribI4sv');
  glVertexAttribI4ubv := load('glVertexAttribI4ubv');
  glVertexAttribI4usv := load('glVertexAttribI4usv');
  glGetUniformuiv := load('glGetUniformuiv');
  glBindFragDataLocation := load('glBindFragDataLocation');
  glGetFragDataLocation := load('glGetFragDataLocation');
  glUniform1ui := load('glUniform1ui');
  glUniform2ui := load('glUniform2ui');
  glUniform3ui := load('glUniform3ui');
  glUniform4ui := load('glUniform4ui');
  glUniform1uiv := load('glUniform1uiv');
  glUniform2uiv := load('glUniform2uiv');
  glUniform3uiv := load('glUniform3uiv');
  glUniform4uiv := load('glUniform4uiv');
  glTexParameterIiv := load('glTexParameterIiv');
  glTexParameterIuiv := load('glTexParameterIuiv');
  glGetTexParameterIiv := load('glGetTexParameterIiv');
  glGetTexParameterIuiv := load('glGetTexParameterIuiv');
  glClearBufferiv := load('glClearBufferiv');
  glClearBufferuiv := load('glClearBufferuiv');
  glClearBufferfv := load('glClearBufferfv');
  glClearBufferfi := load('glClearBufferfi');
  glGetStringi := load('glGetStringi');
  glIsRenderbuffer := load('glIsRenderbuffer');
  glBindRenderbuffer := load('glBindRenderbuffer');
  glDeleteRenderbuffers := load('glDeleteRenderbuffers');
  glGenRenderbuffers := load('glGenRenderbuffers');
  glRenderbufferStorage := load('glRenderbufferStorage');
  glGetRenderbufferParameteriv := load('glGetRenderbufferParameteriv');
  glIsFramebuffer := load('glIsFramebuffer');
  glBindFramebuffer := load('glBindFramebuffer');
  glDeleteFramebuffers := load('glDeleteFramebuffers');
  glGenFramebuffers := load('glGenFramebuffers');
  glCheckFramebufferStatus := load('glCheckFramebufferStatus');
  glFramebufferTexture1D := load('glFramebufferTexture1D');
  glFramebufferTexture2D := load('glFramebufferTexture2D');
  glFramebufferTexture3D := load('glFramebufferTexture3D');
  glFramebufferRenderbuffer := load('glFramebufferRenderbuffer');
  glGetFramebufferAttachmentParameteriv := load('glGetFramebufferAttachmentParameteriv');
  glGenerateMipmap := load('glGenerateMipmap');
  glBlitFramebuffer := load('glBlitFramebuffer');
  glRenderbufferStorageMultisample := load('glRenderbufferStorageMultisample');
  glFramebufferTextureLayer := load('glFramebufferTextureLayer');
  glMapBufferRange := load('glMapBufferRange');
  glFlushMappedBufferRange := load('glFlushMappedBufferRange');
  glBindVertexArray := load('glBindVertexArray');
  glDeleteVertexArrays := load('glDeleteVertexArrays');
  glGenVertexArrays := load('glGenVertexArrays');
  glIsVertexArray := load('glIsVertexArray');
end;

procedure load_GL_VERSION_3_1(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_3_1 then begin
    exit;
  end;
  glDrawArraysInstanced := load('glDrawArraysInstanced');
  glDrawElementsInstanced := load('glDrawElementsInstanced');
  glTexBuffer := load('glTexBuffer');
  glPrimitiveRestartIndex := load('glPrimitiveRestartIndex');
  glCopyBufferSubData := load('glCopyBufferSubData');
  glGetUniformIndices := load('glGetUniformIndices');
  glGetActiveUniformsiv := load('glGetActiveUniformsiv');
  glGetActiveUniformName := load('glGetActiveUniformName');
  glGetUniformBlockIndex := load('glGetUniformBlockIndex');
  glGetActiveUniformBlockiv := load('glGetActiveUniformBlockiv');
  glGetActiveUniformBlockName := load('glGetActiveUniformBlockName');
  glUniformBlockBinding := load('glUniformBlockBinding');
  glBindBufferRange := load('glBindBufferRange');
  glBindBufferBase := load('glBindBufferBase');
  glGetIntegeri_v := load('glGetIntegeri_v');
end;

procedure load_GL_VERSION_3_2(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_3_2 then begin
    exit;
  end;
  glDrawElementsBaseVertex := load('glDrawElementsBaseVertex');
  glDrawRangeElementsBaseVertex := load('glDrawRangeElementsBaseVertex');
  glDrawElementsInstancedBaseVertex := load('glDrawElementsInstancedBaseVertex');
  glMultiDrawElementsBaseVertex := load('glMultiDrawElementsBaseVertex');
  glProvokingVertex := load('glProvokingVertex');
  glFenceSync := load('glFenceSync');
  glIsSync := load('glIsSync');
  glDeleteSync := load('glDeleteSync');
  glClientWaitSync := load('glClientWaitSync');
  glWaitSync := load('glWaitSync');
  glGetInteger64v := load('glGetInteger64v');
  glGetSynciv := load('glGetSynciv');
  glGetInteger64i_v := load('glGetInteger64i_v');
  glGetBufferParameteri64v := load('glGetBufferParameteri64v');
  glFramebufferTexture := load('glFramebufferTexture');
  glTexImage2DMultisample := load('glTexImage2DMultisample');
  glTexImage3DMultisample := load('glTexImage3DMultisample');
  glGetMultisamplefv := load('glGetMultisamplefv');
  glSampleMaski := load('glSampleMaski');
end;

procedure load_GL_VERSION_3_3(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_3_3 then begin
    exit;
  end;
  glBindFragDataLocationIndexed := load('glBindFragDataLocationIndexed');
  glGetFragDataIndex := load('glGetFragDataIndex');
  glGenSamplers := load('glGenSamplers');
  glDeleteSamplers := load('glDeleteSamplers');
  glIsSampler := load('glIsSampler');
  glBindSampler := load('glBindSampler');
  glSamplerParameteri := load('glSamplerParameteri');
  glSamplerParameteriv := load('glSamplerParameteriv');
  glSamplerParameterf := load('glSamplerParameterf');
  glSamplerParameterfv := load('glSamplerParameterfv');
  glSamplerParameterIiv := load('glSamplerParameterIiv');
  glSamplerParameterIuiv := load('glSamplerParameterIuiv');
  glGetSamplerParameteriv := load('glGetSamplerParameteriv');
  glGetSamplerParameterIiv := load('glGetSamplerParameterIiv');
  glGetSamplerParameterfv := load('glGetSamplerParameterfv');
  glGetSamplerParameterIuiv := load('glGetSamplerParameterIuiv');
  glQueryCounter := load('glQueryCounter');
  glGetQueryObjecti64v := load('glGetQueryObjecti64v');
  glGetQueryObjectui64v := load('glGetQueryObjectui64v');
  glVertexAttribDivisor := load('glVertexAttribDivisor');
  glVertexAttribP1ui := load('glVertexAttribP1ui');
  glVertexAttribP1uiv := load('glVertexAttribP1uiv');
  glVertexAttribP2ui := load('glVertexAttribP2ui');
  glVertexAttribP2uiv := load('glVertexAttribP2uiv');
  glVertexAttribP3ui := load('glVertexAttribP3ui');
  glVertexAttribP3uiv := load('glVertexAttribP3uiv');
  glVertexAttribP4ui := load('glVertexAttribP4ui');
  glVertexAttribP4uiv := load('glVertexAttribP4uiv');
  glVertexP2ui := load('glVertexP2ui');
  glVertexP2uiv := load('glVertexP2uiv');
  glVertexP3ui := load('glVertexP3ui');
  glVertexP3uiv := load('glVertexP3uiv');
  glVertexP4ui := load('glVertexP4ui');
  glVertexP4uiv := load('glVertexP4uiv');
  glTexCoordP1ui := load('glTexCoordP1ui');
  glTexCoordP1uiv := load('glTexCoordP1uiv');
  glTexCoordP2ui := load('glTexCoordP2ui');
  glTexCoordP2uiv := load('glTexCoordP2uiv');
  glTexCoordP3ui := load('glTexCoordP3ui');
  glTexCoordP3uiv := load('glTexCoordP3uiv');
  glTexCoordP4ui := load('glTexCoordP4ui');
  glTexCoordP4uiv := load('glTexCoordP4uiv');
  glMultiTexCoordP1ui := load('glMultiTexCoordP1ui');
  glMultiTexCoordP1uiv := load('glMultiTexCoordP1uiv');
  glMultiTexCoordP2ui := load('glMultiTexCoordP2ui');
  glMultiTexCoordP2uiv := load('glMultiTexCoordP2uiv');
  glMultiTexCoordP3ui := load('glMultiTexCoordP3ui');
  glMultiTexCoordP3uiv := load('glMultiTexCoordP3uiv');
  glMultiTexCoordP4ui := load('glMultiTexCoordP4ui');
  glMultiTexCoordP4uiv := load('glMultiTexCoordP4uiv');
  glNormalP3ui := load('glNormalP3ui');
  glNormalP3uiv := load('glNormalP3uiv');
  glColorP3ui := load('glColorP3ui');
  glColorP3uiv := load('glColorP3uiv');
  glColorP4ui := load('glColorP4ui');
  glColorP4uiv := load('glColorP4uiv');
  glSecondaryColorP3ui := load('glSecondaryColorP3ui');
  glSecondaryColorP3uiv := load('glSecondaryColorP3uiv');
end;

procedure load_GL_VERSION_4_0(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_4_0 then begin
    exit;
  end;
  glMinSampleShading := load('glMinSampleShading');
  glBlendEquationi := load('glBlendEquationi');
  glBlendEquationSeparatei := load('glBlendEquationSeparatei');
  glBlendFunci := load('glBlendFunci');
  glBlendFuncSeparatei := load('glBlendFuncSeparatei');
  glDrawArraysIndirect := load('glDrawArraysIndirect');
  glDrawElementsIndirect := load('glDrawElementsIndirect');
  glUniform1d := load('glUniform1d');
  glUniform2d := load('glUniform2d');
  glUniform3d := load('glUniform3d');
  glUniform4d := load('glUniform4d');
  glUniform1dv := load('glUniform1dv');
  glUniform2dv := load('glUniform2dv');
  glUniform3dv := load('glUniform3dv');
  glUniform4dv := load('glUniform4dv');
  glUniformMatrix2dv := load('glUniformMatrix2dv');
  glUniformMatrix3dv := load('glUniformMatrix3dv');
  glUniformMatrix4dv := load('glUniformMatrix4dv');
  glUniformMatrix2x3dv := load('glUniformMatrix2x3dv');
  glUniformMatrix2x4dv := load('glUniformMatrix2x4dv');
  glUniformMatrix3x2dv := load('glUniformMatrix3x2dv');
  glUniformMatrix3x4dv := load('glUniformMatrix3x4dv');
  glUniformMatrix4x2dv := load('glUniformMatrix4x2dv');
  glUniformMatrix4x3dv := load('glUniformMatrix4x3dv');
  glGetUniformdv := load('glGetUniformdv');
  glGetSubroutineUniformLocation := load('glGetSubroutineUniformLocation');
  glGetSubroutineIndex := load('glGetSubroutineIndex');
  glGetActiveSubroutineUniformiv := load('glGetActiveSubroutineUniformiv');
  glGetActiveSubroutineUniformName := load('glGetActiveSubroutineUniformName');
  glGetActiveSubroutineName := load('glGetActiveSubroutineName');
  glUniformSubroutinesuiv := load('glUniformSubroutinesuiv');
  glGetUniformSubroutineuiv := load('glGetUniformSubroutineuiv');
  glGetProgramStageiv := load('glGetProgramStageiv');
  glPatchParameteri := load('glPatchParameteri');
  glPatchParameterfv := load('glPatchParameterfv');
  glBindTransformFeedback := load('glBindTransformFeedback');
  glDeleteTransformFeedbacks := load('glDeleteTransformFeedbacks');
  glGenTransformFeedbacks := load('glGenTransformFeedbacks');
  glIsTransformFeedback := load('glIsTransformFeedback');
  glPauseTransformFeedback := load('glPauseTransformFeedback');
  glResumeTransformFeedback := load('glResumeTransformFeedback');
  glDrawTransformFeedback := load('glDrawTransformFeedback');
  glDrawTransformFeedbackStream := load('glDrawTransformFeedbackStream');
  glBeginQueryIndexed := load('glBeginQueryIndexed');
  glEndQueryIndexed := load('glEndQueryIndexed');
  glGetQueryIndexediv := load('glGetQueryIndexediv');
end;

procedure load_GL_VERSION_4_1(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_4_1 then begin
    exit;
  end;
  glReleaseShaderCompiler := load('glReleaseShaderCompiler');
  glShaderBinary := load('glShaderBinary');
  glGetShaderPrecisionFormat := load('glGetShaderPrecisionFormat');
  glDepthRangef := load('glDepthRangef');
  glClearDepthf := load('glClearDepthf');
  glGetProgramBinary := load('glGetProgramBinary');
  glProgramBinary := load('glProgramBinary');
  glProgramParameteri := load('glProgramParameteri');
  glUseProgramStages := load('glUseProgramStages');
  glActiveShaderProgram := load('glActiveShaderProgram');
  glCreateShaderProgramv := load('glCreateShaderProgramv');
  glBindProgramPipeline := load('glBindProgramPipeline');
  glDeleteProgramPipelines := load('glDeleteProgramPipelines');
  glGenProgramPipelines := load('glGenProgramPipelines');
  glIsProgramPipeline := load('glIsProgramPipeline');
  glGetProgramPipelineiv := load('glGetProgramPipelineiv');
  glProgramParameteri := load('glProgramParameteri');
  glProgramUniform1i := load('glProgramUniform1i');
  glProgramUniform1iv := load('glProgramUniform1iv');
  glProgramUniform1f := load('glProgramUniform1f');
  glProgramUniform1fv := load('glProgramUniform1fv');
  glProgramUniform1d := load('glProgramUniform1d');
  glProgramUniform1dv := load('glProgramUniform1dv');
  glProgramUniform1ui := load('glProgramUniform1ui');
  glProgramUniform1uiv := load('glProgramUniform1uiv');
  glProgramUniform2i := load('glProgramUniform2i');
  glProgramUniform2iv := load('glProgramUniform2iv');
  glProgramUniform2f := load('glProgramUniform2f');
  glProgramUniform2fv := load('glProgramUniform2fv');
  glProgramUniform2d := load('glProgramUniform2d');
  glProgramUniform2dv := load('glProgramUniform2dv');
  glProgramUniform2ui := load('glProgramUniform2ui');
  glProgramUniform2uiv := load('glProgramUniform2uiv');
  glProgramUniform3i := load('glProgramUniform3i');
  glProgramUniform3iv := load('glProgramUniform3iv');
  glProgramUniform3f := load('glProgramUniform3f');
  glProgramUniform3fv := load('glProgramUniform3fv');
  glProgramUniform3d := load('glProgramUniform3d');
  glProgramUniform3dv := load('glProgramUniform3dv');
  glProgramUniform3ui := load('glProgramUniform3ui');
  glProgramUniform3uiv := load('glProgramUniform3uiv');
  glProgramUniform4i := load('glProgramUniform4i');
  glProgramUniform4iv := load('glProgramUniform4iv');
  glProgramUniform4f := load('glProgramUniform4f');
  glProgramUniform4fv := load('glProgramUniform4fv');
  glProgramUniform4d := load('glProgramUniform4d');
  glProgramUniform4dv := load('glProgramUniform4dv');
  glProgramUniform4ui := load('glProgramUniform4ui');
  glProgramUniform4uiv := load('glProgramUniform4uiv');
  glProgramUniformMatrix2fv := load('glProgramUniformMatrix2fv');
  glProgramUniformMatrix3fv := load('glProgramUniformMatrix3fv');
  glProgramUniformMatrix4fv := load('glProgramUniformMatrix4fv');
  glProgramUniformMatrix2dv := load('glProgramUniformMatrix2dv');
  glProgramUniformMatrix3dv := load('glProgramUniformMatrix3dv');
  glProgramUniformMatrix4dv := load('glProgramUniformMatrix4dv');
  glProgramUniformMatrix2x3fv := load('glProgramUniformMatrix2x3fv');
  glProgramUniformMatrix3x2fv := load('glProgramUniformMatrix3x2fv');
  glProgramUniformMatrix2x4fv := load('glProgramUniformMatrix2x4fv');
  glProgramUniformMatrix4x2fv := load('glProgramUniformMatrix4x2fv');
  glProgramUniformMatrix3x4fv := load('glProgramUniformMatrix3x4fv');
  glProgramUniformMatrix4x3fv := load('glProgramUniformMatrix4x3fv');
  glProgramUniformMatrix2x3dv := load('glProgramUniformMatrix2x3dv');
  glProgramUniformMatrix3x2dv := load('glProgramUniformMatrix3x2dv');
  glProgramUniformMatrix2x4dv := load('glProgramUniformMatrix2x4dv');
  glProgramUniformMatrix4x2dv := load('glProgramUniformMatrix4x2dv');
  glProgramUniformMatrix3x4dv := load('glProgramUniformMatrix3x4dv');
  glProgramUniformMatrix4x3dv := load('glProgramUniformMatrix4x3dv');
  glValidateProgramPipeline := load('glValidateProgramPipeline');
  glGetProgramPipelineInfoLog := load('glGetProgramPipelineInfoLog');
  glVertexAttribL1d := load('glVertexAttribL1d');
  glVertexAttribL2d := load('glVertexAttribL2d');
  glVertexAttribL3d := load('glVertexAttribL3d');
  glVertexAttribL4d := load('glVertexAttribL4d');
  glVertexAttribL1dv := load('glVertexAttribL1dv');
  glVertexAttribL2dv := load('glVertexAttribL2dv');
  glVertexAttribL3dv := load('glVertexAttribL3dv');
  glVertexAttribL4dv := load('glVertexAttribL4dv');
  glVertexAttribLPointer := load('glVertexAttribLPointer');
  glGetVertexAttribLdv := load('glGetVertexAttribLdv');
  glViewportArrayv := load('glViewportArrayv');
  glViewportIndexedf := load('glViewportIndexedf');
  glViewportIndexedfv := load('glViewportIndexedfv');
  glScissorArrayv := load('glScissorArrayv');
  glScissorIndexed := load('glScissorIndexed');
  glScissorIndexedv := load('glScissorIndexedv');
  glDepthRangeArrayv := load('glDepthRangeArrayv');
  glDepthRangeIndexed := load('glDepthRangeIndexed');
  glGetFloati_v := load('glGetFloati_v');
  glGetDoublei_v := load('glGetDoublei_v');
end;

procedure load_GL_VERSION_4_2(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_4_2 then begin
    exit;
  end;
  glDrawArraysInstancedBaseInstance := load('glDrawArraysInstancedBaseInstance');
  glDrawElementsInstancedBaseInstance := load('glDrawElementsInstancedBaseInstance');
  glDrawElementsInstancedBaseVertexBaseInstance := load('glDrawElementsInstancedBaseVertexBaseInstance');
  glGetInternalformativ := load('glGetInternalformativ');
  glGetActiveAtomicCounterBufferiv := load('glGetActiveAtomicCounterBufferiv');
  glBindImageTexture := load('glBindImageTexture');
  glMemoryBarrier := load('glMemoryBarrier');
  glTexStorage1D := load('glTexStorage1D');
  glTexStorage2D := load('glTexStorage2D');
  glTexStorage3D := load('glTexStorage3D');
  glDrawTransformFeedbackInstanced := load('glDrawTransformFeedbackInstanced');
  glDrawTransformFeedbackStreamInstanced := load('glDrawTransformFeedbackStreamInstanced');
end;

procedure load_GL_VERSION_4_3(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_4_3 then begin
    exit;
  end;
  glClearBufferData := load('glClearBufferData');
  glClearBufferSubData := load('glClearBufferSubData');
  glDispatchCompute := load('glDispatchCompute');
  glDispatchComputeIndirect := load('glDispatchComputeIndirect');
  glCopyImageSubData := load('glCopyImageSubData');
  glFramebufferParameteri := load('glFramebufferParameteri');
  glGetFramebufferParameteriv := load('glGetFramebufferParameteriv');
  glGetInternalformati64v := load('glGetInternalformati64v');
  glInvalidateTexSubImage := load('glInvalidateTexSubImage');
  glInvalidateTexImage := load('glInvalidateTexImage');
  glInvalidateBufferSubData := load('glInvalidateBufferSubData');
  glInvalidateBufferData := load('glInvalidateBufferData');
  glInvalidateFramebuffer := load('glInvalidateFramebuffer');
  glInvalidateSubFramebuffer := load('glInvalidateSubFramebuffer');
  glMultiDrawArraysIndirect := load('glMultiDrawArraysIndirect');
  glMultiDrawElementsIndirect := load('glMultiDrawElementsIndirect');
  glGetProgramInterfaceiv := load('glGetProgramInterfaceiv');
  glGetProgramResourceIndex := load('glGetProgramResourceIndex');
  glGetProgramResourceName := load('glGetProgramResourceName');
  glGetProgramResourceiv := load('glGetProgramResourceiv');
  glGetProgramResourceLocation := load('glGetProgramResourceLocation');
  glGetProgramResourceLocationIndex := load('glGetProgramResourceLocationIndex');
  glShaderStorageBlockBinding := load('glShaderStorageBlockBinding');
  glTexBufferRange := load('glTexBufferRange');
  glTexStorage2DMultisample := load('glTexStorage2DMultisample');
  glTexStorage3DMultisample := load('glTexStorage3DMultisample');
  glTextureView := load('glTextureView');
  glBindVertexBuffer := load('glBindVertexBuffer');
  glVertexAttribFormat := load('glVertexAttribFormat');
  glVertexAttribIFormat := load('glVertexAttribIFormat');
  glVertexAttribLFormat := load('glVertexAttribLFormat');
  glVertexAttribBinding := load('glVertexAttribBinding');
  glVertexBindingDivisor := load('glVertexBindingDivisor');
  glDebugMessageControl := load('glDebugMessageControl');
  glDebugMessageInsert := load('glDebugMessageInsert');
  glDebugMessageCallback := load('glDebugMessageCallback');
  glGetDebugMessageLog := load('glGetDebugMessageLog');
  glPushDebugGroup := load('glPushDebugGroup');
  glPopDebugGroup := load('glPopDebugGroup');
  glObjectLabel := load('glObjectLabel');
  glGetObjectLabel := load('glGetObjectLabel');
  glObjectPtrLabel := load('glObjectPtrLabel');
  glGetObjectPtrLabel := load('glGetObjectPtrLabel');
  glGetPointerv := load('glGetPointerv');
end;

procedure load_GL_VERSION_4_4(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_4_4 then begin
    exit;
  end;
  glBufferStorage := load('glBufferStorage');
  glClearTexImage := load('glClearTexImage');
  glClearTexSubImage := load('glClearTexSubImage');
  glBindBuffersBase := load('glBindBuffersBase');
  glBindBuffersRange := load('glBindBuffersRange');
  glBindTextures := load('glBindTextures');
  glBindSamplers := load('glBindSamplers');
  glBindImageTextures := load('glBindImageTextures');
  glBindVertexBuffers := load('glBindVertexBuffers');
end;

procedure load_GL_VERSION_4_5(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_4_5 then begin
    exit;
  end;
  glClipControl := load('glClipControl');
  glCreateTransformFeedbacks := load('glCreateTransformFeedbacks');
  glTransformFeedbackBufferBase := load('glTransformFeedbackBufferBase');
  glTransformFeedbackBufferRange := load('glTransformFeedbackBufferRange');
  glGetTransformFeedbackiv := load('glGetTransformFeedbackiv');
  glGetTransformFeedbacki_v := load('glGetTransformFeedbacki_v');
  glGetTransformFeedbacki64_v := load('glGetTransformFeedbacki64_v');
  glCreateBuffers := load('glCreateBuffers');
  glNamedBufferStorage := load('glNamedBufferStorage');
  glNamedBufferData := load('glNamedBufferData');
  glNamedBufferSubData := load('glNamedBufferSubData');
  glCopyNamedBufferSubData := load('glCopyNamedBufferSubData');
  glClearNamedBufferData := load('glClearNamedBufferData');
  glClearNamedBufferSubData := load('glClearNamedBufferSubData');
  glMapNamedBuffer := load('glMapNamedBuffer');
  glMapNamedBufferRange := load('glMapNamedBufferRange');
  glUnmapNamedBuffer := load('glUnmapNamedBuffer');
  glFlushMappedNamedBufferRange := load('glFlushMappedNamedBufferRange');
  glGetNamedBufferParameteriv := load('glGetNamedBufferParameteriv');
  glGetNamedBufferParameteri64v := load('glGetNamedBufferParameteri64v');
  glGetNamedBufferPointerv := load('glGetNamedBufferPointerv');
  glGetNamedBufferSubData := load('glGetNamedBufferSubData');
  glCreateFramebuffers := load('glCreateFramebuffers');
  glNamedFramebufferRenderbuffer := load('glNamedFramebufferRenderbuffer');
  glNamedFramebufferParameteri := load('glNamedFramebufferParameteri');
  glNamedFramebufferTexture := load('glNamedFramebufferTexture');
  glNamedFramebufferTextureLayer := load('glNamedFramebufferTextureLayer');
  glNamedFramebufferDrawBuffer := load('glNamedFramebufferDrawBuffer');
  glNamedFramebufferDrawBuffers := load('glNamedFramebufferDrawBuffers');
  glNamedFramebufferReadBuffer := load('glNamedFramebufferReadBuffer');
  glInvalidateNamedFramebufferData := load('glInvalidateNamedFramebufferData');
  glInvalidateNamedFramebufferSubData := load('glInvalidateNamedFramebufferSubData');
  glClearNamedFramebufferiv := load('glClearNamedFramebufferiv');
  glClearNamedFramebufferuiv := load('glClearNamedFramebufferuiv');
  glClearNamedFramebufferfv := load('glClearNamedFramebufferfv');
  glClearNamedFramebufferfi := load('glClearNamedFramebufferfi');
  glBlitNamedFramebuffer := load('glBlitNamedFramebuffer');
  glCheckNamedFramebufferStatus := load('glCheckNamedFramebufferStatus');
  glGetNamedFramebufferParameteriv := load('glGetNamedFramebufferParameteriv');
  glGetNamedFramebufferAttachmentParameteriv := load('glGetNamedFramebufferAttachmentParameteriv');
  glCreateRenderbuffers := load('glCreateRenderbuffers');
  glNamedRenderbufferStorage := load('glNamedRenderbufferStorage');
  glNamedRenderbufferStorageMultisample := load('glNamedRenderbufferStorageMultisample');
  glGetNamedRenderbufferParameteriv := load('glGetNamedRenderbufferParameteriv');
  glCreateTextures := load('glCreateTextures');
  glTextureBuffer := load('glTextureBuffer');
  glTextureBufferRange := load('glTextureBufferRange');
  glTextureStorage1D := load('glTextureStorage1D');
  glTextureStorage2D := load('glTextureStorage2D');
  glTextureStorage3D := load('glTextureStorage3D');
  glTextureStorage2DMultisample := load('glTextureStorage2DMultisample');
  glTextureStorage3DMultisample := load('glTextureStorage3DMultisample');
  glTextureSubImage1D := load('glTextureSubImage1D');
  glTextureSubImage2D := load('glTextureSubImage2D');
  glTextureSubImage3D := load('glTextureSubImage3D');
  glCompressedTextureSubImage1D := load('glCompressedTextureSubImage1D');
  glCompressedTextureSubImage2D := load('glCompressedTextureSubImage2D');
  glCompressedTextureSubImage3D := load('glCompressedTextureSubImage3D');
  glCopyTextureSubImage1D := load('glCopyTextureSubImage1D');
  glCopyTextureSubImage2D := load('glCopyTextureSubImage2D');
  glCopyTextureSubImage3D := load('glCopyTextureSubImage3D');
  glTextureParameterf := load('glTextureParameterf');
  glTextureParameterfv := load('glTextureParameterfv');
  glTextureParameteri := load('glTextureParameteri');
  glTextureParameterIiv := load('glTextureParameterIiv');
  glTextureParameterIuiv := load('glTextureParameterIuiv');
  glTextureParameteriv := load('glTextureParameteriv');
  glGenerateTextureMipmap := load('glGenerateTextureMipmap');
  glBindTextureUnit := load('glBindTextureUnit');
  glGetTextureImage := load('glGetTextureImage');
  glGetCompressedTextureImage := load('glGetCompressedTextureImage');
  glGetTextureLevelParameterfv := load('glGetTextureLevelParameterfv');
  glGetTextureLevelParameteriv := load('glGetTextureLevelParameteriv');
  glGetTextureParameterfv := load('glGetTextureParameterfv');
  glGetTextureParameterIiv := load('glGetTextureParameterIiv');
  glGetTextureParameterIuiv := load('glGetTextureParameterIuiv');
  glGetTextureParameteriv := load('glGetTextureParameteriv');
  glCreateVertexArrays := load('glCreateVertexArrays');
  glDisableVertexArrayAttrib := load('glDisableVertexArrayAttrib');
  glEnableVertexArrayAttrib := load('glEnableVertexArrayAttrib');
  glVertexArrayElementBuffer := load('glVertexArrayElementBuffer');
  glVertexArrayVertexBuffer := load('glVertexArrayVertexBuffer');
  glVertexArrayVertexBuffers := load('glVertexArrayVertexBuffers');
  glVertexArrayAttribBinding := load('glVertexArrayAttribBinding');
  glVertexArrayAttribFormat := load('glVertexArrayAttribFormat');
  glVertexArrayAttribIFormat := load('glVertexArrayAttribIFormat');
  glVertexArrayAttribLFormat := load('glVertexArrayAttribLFormat');
  glVertexArrayBindingDivisor := load('glVertexArrayBindingDivisor');
  glGetVertexArrayiv := load('glGetVertexArrayiv');
  glGetVertexArrayIndexediv := load('glGetVertexArrayIndexediv');
  glGetVertexArrayIndexed64iv := load('glGetVertexArrayIndexed64iv');
  glCreateSamplers := load('glCreateSamplers');
  glCreateProgramPipelines := load('glCreateProgramPipelines');
  glCreateQueries := load('glCreateQueries');
  glGetQueryBufferObjecti64v := load('glGetQueryBufferObjecti64v');
  glGetQueryBufferObjectiv := load('glGetQueryBufferObjectiv');
  glGetQueryBufferObjectui64v := load('glGetQueryBufferObjectui64v');
  glGetQueryBufferObjectuiv := load('glGetQueryBufferObjectuiv');
  glMemoryBarrierByRegion := load('glMemoryBarrierByRegion');
  glGetTextureSubImage := load('glGetTextureSubImage');
  glGetCompressedTextureSubImage := load('glGetCompressedTextureSubImage');
  glGetGraphicsResetStatus := load('glGetGraphicsResetStatus');
  glGetnCompressedTexImage := load('glGetnCompressedTexImage');
  glGetnTexImage := load('glGetnTexImage');
  glGetnUniformdv := load('glGetnUniformdv');
  glGetnUniformfv := load('glGetnUniformfv');
  glGetnUniformiv := load('glGetnUniformiv');
  glGetnUniformuiv := load('glGetnUniformuiv');
  glReadnPixels := load('glReadnPixels');
  glGetnMapdv := load('glGetnMapdv');
  glGetnMapfv := load('glGetnMapfv');
  glGetnMapiv := load('glGetnMapiv');
  glGetnPixelMapfv := load('glGetnPixelMapfv');
  glGetnPixelMapuiv := load('glGetnPixelMapuiv');
  glGetnPixelMapusv := load('glGetnPixelMapusv');
  glGetnPolygonStipple := load('glGetnPolygonStipple');
  glGetnColorTable := load('glGetnColorTable');
  glGetnConvolutionFilter := load('glGetnConvolutionFilter');
  glGetnSeparableFilter := load('glGetnSeparableFilter');
  glGetnHistogram := load('glGetnHistogram');
  glGetnMinmax := load('glGetnMinmax');
  glTextureBarrier := load('glTextureBarrier');
end;

procedure load_GL_VERSION_4_6(load: TLoadProc);
begin
  if not GLAD_GL_VERSION_4_6 then begin
    exit;
  end;
  glSpecializeShader := load('glSpecializeShader');
  glMultiDrawArraysIndirectCount := load('glMultiDrawArraysIndirectCount');
  glMultiDrawElementsIndirectCount := load('glMultiDrawElementsIndirectCount');
  glPolygonOffsetClamp := load('glPolygonOffsetClamp');
end;

procedure findExtensionsGL();
begin
end;

procedure findCoreGL(glVersion: string);
{ Thank you @elmindreda
  https://github.com/elmindreda/greg/blob/master/templates/greg.c.in//L176
  https://github.com/glfw/glfw/blob/master/src/context.c//L36 }
const
  prefixes: array[0..2] of string = ('OpenGL ES-CM ', 'OpenGL ES-CL ', 'OpenGL ES ');
var
  version, p: string;
  major, minor: integer;
begin
  version := glVersion;
  for p in prefixes do begin
    if LeftStr(version, length(p)) = p then begin
      version := StringReplace(version, p, '', [rfReplaceAll]);
      break;
    end;
  end;

  major := Ord(version[1]) - Ord('0');
  minor := Ord(version[3]) - Ord('0');

  glVersionMajor := major;
  glVersionMinor := minor;

  GLAD_GL_VERSION_1_0 := ((major = 1) and (minor >= 0)) or (major > 1);
  GLAD_GL_VERSION_1_1 := ((major = 1) and (minor >= 1)) or (major > 1);
  GLAD_GL_VERSION_1_2 := ((major = 1) and (minor >= 2)) or (major > 1);
  GLAD_GL_VERSION_1_3 := ((major = 1) and (minor >= 3)) or (major > 1);
  GLAD_GL_VERSION_1_4 := ((major = 1) and (minor >= 4)) or (major > 1);
  GLAD_GL_VERSION_1_5 := ((major = 1) and (minor >= 5)) or (major > 1);
  GLAD_GL_VERSION_2_0 := ((major = 2) and (minor >= 0)) or (major > 2);
  GLAD_GL_VERSION_2_1 := ((major = 2) and (minor >= 1)) or (major > 2);
  GLAD_GL_VERSION_3_0 := ((major = 3) and (minor >= 0)) or (major > 3);
  GLAD_GL_VERSION_3_1 := ((major = 3) and (minor >= 1)) or (major > 3);
  GLAD_GL_VERSION_3_2 := ((major = 3) and (minor >= 2)) or (major > 3);
  GLAD_GL_VERSION_3_3 := ((major = 3) and (minor >= 3)) or (major > 3);
  GLAD_GL_VERSION_4_0 := ((major = 4) and (minor >= 0)) or (major > 4);
  GLAD_GL_VERSION_4_1 := ((major = 4) and (minor >= 1)) or (major > 4);
  GLAD_GL_VERSION_4_2 := ((major = 4) and (minor >= 2)) or (major > 4);
  GLAD_GL_VERSION_4_3 := ((major = 4) and (minor >= 3)) or (major > 4);
  GLAD_GL_VERSION_4_4 := ((major = 4) and (minor >= 4)) or (major > 4);
  GLAD_GL_VERSION_4_5 := ((major = 4) and (minor >= 5)) or (major > 4);
  GLAD_GL_VERSION_4_6 := ((major = 4) and (minor >= 6)) or (major > 4);
end;

function gladLoadGL(load: TLoadProc): boolean;
var
  glVersion: pansichar;
begin
  glGetString := load('glGetString');
  if not Assigned(glGetString) then begin
    exit(False);
  end;
  glVersion := pansichar(glGetString(GL_VERSION));
  if glVersion = nil then begin
    exit(False);
  end;

  findCoreGL(glVersion);
  load_GL_VERSION_1_0(load);
  load_GL_VERSION_1_1(load);
  load_GL_VERSION_1_2(load);
  load_GL_VERSION_1_3(load);
  load_GL_VERSION_1_4(load);
  load_GL_VERSION_1_5(load);
  load_GL_VERSION_2_0(load);
  load_GL_VERSION_2_1(load);
  load_GL_VERSION_3_0(load);
  load_GL_VERSION_3_1(load);
  load_GL_VERSION_3_2(load);
  load_GL_VERSION_3_3(load);
  load_GL_VERSION_4_0(load);
  load_GL_VERSION_4_1(load);
  load_GL_VERSION_4_2(load);
  load_GL_VERSION_4_3(load);
  load_GL_VERSION_4_4(load);
  load_GL_VERSION_4_5(load);
  load_GL_VERSION_4_6(load);

  findExtensionsGL();

  Result := (glVersionMajor <> 0) or (glVersionMinor <> 0);
end;

// === Eigenes

var
  LibGL: TLibHandle;

{$IFDEF Linux}
function wglGetProcAddress(proc: pansichar): Pointer;
begin
  Result := GetProcAddress(LibGL, proc);
end;
{$ENDIF}

{$IFDEF Windows}
function wglGetProcAddress(proc: pansichar): Pointer; cdecl external 'OpenGL32.dll';
{$ENDIF}

function LoadProc(proc: pansichar): TLoadProc;
begin
  Result := GetProcAddress(LibGL, proc);
  {$IFDEF Windows}
  {$push}
  {$i-}
//  WriteLn('');
  {$pop}
  if @Result = nil then  begin
    Result := wglGetProcAddress(proc);
  end;
  {$ENDIF}
end;

procedure Load_GLADE;
begin
  {$IFDEF Linux}
  LibGL := LoadLibrary(pansichar('libGL.so.1'));
  {$ENDIF}
  {$IFDEF Windows}
  LibGL := LoadLibrary(pansichar('OpenGL32.dll'));
  {$ENDIF}
  gladLoadGL(@LoadProc);
end;

end.
